<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>jam.do</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #f5f0e8;
            color: #2a2a2a;
            line-height: 1.6;
        }

        #viewport {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
        }

        #grid-container {
            position: relative;
        }

        .tile {
            position: absolute;
            overflow: hidden;
        }

        .tile img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .tile.color-fill {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .post-tile {
            background: #fffef8;
            padding: 20px;
            overflow-y: auto;
            border: 1px solid #e0d5c8;
        }

        .post-tile h1 {
            font-size: 1.2rem;
            margin-bottom: 0.8rem;
            font-weight: 600;
        }

        .post-tile h2 {
            font-size: 1rem;
            margin: 1rem 0 0.5rem;
            font-weight: 600;
        }

        .post-tile h3 {
            font-size: 0.9rem;
            margin: 0.8rem 0 0.4rem;
            font-weight: 600;
        }

        .post-tile p {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
        }

        .post-tile a {
            color: #c45c3e;
            text-decoration: underline;
            text-underline-offset: 2px;
        }

        .post-tile pre {
            background: #f5f0e8;
            padding: 8px;
            overflow-x: auto;
            margin: 0.8rem 0;
            font-family: monospace;
            font-size: 0.75rem;
        }

        .post-tile code {
            font-family: monospace;
            background: #f5f0e8;
            padding: 2px 4px;
            font-size: 0.85em;
        }

        .post-tile blockquote {
            border-left: 2px solid #c45c3e;
            padding-left: 0.8rem;
            margin: 0.8rem 0;
            color: #555;
        }

        .post-tile ul, .post-tile ol {
            margin: 0.8rem 0 0.8rem 1.5rem;
        }

        .post-tile li {
            margin-bottom: 0.3rem;
        }

        #loader {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.9rem;
            color: #888;
            z-index: 100;
        }

        #debug {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: #0f0;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            z-index: 1000;
            max-width: 300px;
            max-height: 200px;
            overflow: auto;
            display: none;
        }
    </style>
</head>
<body>
    <div id="loader">loading...</div>
    <div id="debug"></div>
    <div id="viewport">
        <div id="grid-container"></div>
    </div>

    <script>
        const warmPastels = [
            '#e8d5c4', '#d4c4b0', '#c9b8a4', '#e6d5c9',
            '#f0e6d8', '#e4d4c0', '#d9c9b6', '#f5ebe0',
            '#e8ddd4', '#ddd0c0', '#f2e6d8', '#e5d9cc',
            '#f0e8e0', '#e8e0d5', '#ddd5c8', '#ede5d8'
        ];

        const ABSOLUTE_MIN_TILE = 200;
        const ABSOLUTE_MAX_TILE = 600;
        const POST_MIN_WIDTH = 500;
        const POST_MAX_WIDTH = 900;
        const POST_MIN_HEIGHT = 350;
        const POST_MAX_HEIGHT = 600;
        const MARGIN = 30;
        const BUFFER_TILES = 2;
        const POST_STRIP_CHANCE = 0.25;

        const container = document.getElementById('grid-container');
        const viewport = document.getElementById('viewport');
        
        let posts = [];
        let images = [];
        let renderedTiles = new Map();
        let postsLoaded = 0;
        let generationY = 0;
        let viewportWidth = 0;
        let viewportHeight = 0;

        function getRandomPastel() {
            return warmPastels[Math.floor(Math.random() * warmPastels.length)];
        }

        function getRandomImage() {
            if (images.length === 0) return null;
            return images[Math.floor(Math.random() * images.length)];
        }

        function getRandomPostWidth() {
            return POST_MIN_WIDTH + Math.random() * (POST_MAX_WIDTH - POST_MIN_WIDTH);
        }

        function getRandomPostHeight() {
            return POST_MIN_HEIGHT + Math.random() * (POST_MAX_HEIGHT - POST_MIN_HEIGHT);
        }

        // Generate a horizontal strip of tiles
        // If isPostStrip, one tile will be post-sized
        function generateStrip(startY, isPostStrip) {
            const tiles = [];
            let currentX = 0;
            
            if (isPostStrip && postsLoaded < posts.length) {
                // Post strip: fixed height, fill width with tiles, one is post-sized
                const stripHeight = getRandomPostHeight();
                const postWidth = getRandomPostWidth();
                const postX = MARGIN + Math.random() * Math.max(0, viewportWidth - postWidth - MARGIN * 2);
                
                // Tile before post
                if (postX > currentX) {
                    const w = postX - currentX;
                    if (w > 50) {
                        tiles.push({
                            x: currentX,
                            y: startY,
                            w: w,
                            h: stripHeight,
                            isPost: false,
                            id: Math.random().toString(36).substr(2, 9)
                        });
                    }
                }
                
                // Post tile
                tiles.push({
                    x: postX,
                    y: startY,
                    w: postWidth,
                    h: stripHeight,
                    isPost: true,
                    postIndex: postsLoaded++,
                    id: 'post-' + (postsLoaded - 1)
                });
                
                // Tile after post
                const afterX = postX + postWidth;
                if (afterX < viewportWidth) {
                    const w = viewportWidth - afterX;
                    if (w > 50) {
                        tiles.push({
                            x: afterX,
                            y: startY,
                            w: w,
                            h: stripHeight,
                            isPost: false,
                            id: Math.random().toString(36).substr(2, 9)
                        });
                    }
                }
                
                return { tiles, height: stripHeight };
            } else {
                // Regular strip: random height, fill width with random tiles
                const stripHeight = ABSOLUTE_MIN_TILE + Math.random() * (ABSOLUTE_MAX_TILE - ABSOLUTE_MIN_TILE);
                
                while (currentX < viewportWidth - 10) {
                    const remaining = viewportWidth - currentX;
                    const maxW = Math.min(remaining, ABSOLUTE_MAX_TILE);
                    const minW = Math.min(ABSOLUTE_MIN_TILE, remaining);
                    const w = remaining < ABSOLUTE_MIN_TILE ? remaining : (minW + Math.random() * (maxW - minW));
                    
                    tiles.push({
                        x: currentX,
                        y: startY,
                        w: w,
                        h: stripHeight,
                        isPost: false,
                        id: Math.random().toString(36).substr(2, 9)
                    });
                    
                    currentX += w;
                }
                
                return { tiles, height: stripHeight };
            }
        }

        async function loadImages() {
            try {
                const response = await fetch('images/index.txt');
                if (!response.ok) throw new Error('No image index');
                const text = await response.text();
                const lines = text.split('\n').filter(l => l.trim());
                images = lines.map(line => {
                    const parts = line.split('|');
                    return { src: `images/${parts[0]}`, alt: parts[1] || '' };
                });
            } catch (e) {
                images = [];
            }
        }

        async function loadPosts() {
            try {
                const response = await fetch('posts/index.txt');
                if (!response.ok) throw new Error('No posts');
                const text = await response.text();
                const urls = text.split('\n').filter(u => u.trim());
                
                for (const url of urls) {
                    try {
                        const res = await fetch(`posts/${url}`);
                        const markdown = await res.text();
                        posts.push({
                            url: url,
                            title: url.replace('.md', '').replace(/-/g, ' '),
                            html: renderMarkdown(markdown)
                        });
                    } catch (e) {
                        console.error('Failed to load post:', url);
                    }
                }
            } catch (e) {
                posts = [];
            }
        }

        function renderMarkdown(markdown) {
            const lines = markdown.split('\n');
            let html = '';
            let inList = false;
            let inBlockquote = false;
            let inCode = false;
            
            lines.forEach(line => {
                if (line.startsWith('```')) {
                    inCode = !inCode;
                    html += inCode ? '<pre><code>' : '</code></pre>';
                    return;
                }
                
                if (inCode) {
                    html += line + '\n';
                    return;
                }
                
                if (line.startsWith('# ')) {
                    html += `<h1>${escapeHtml(line.slice(2))}</h1>`;
                } else if (line.startsWith('## ')) {
                    html += `<h2>${escapeHtml(line.slice(3))}</h2>`;
                } else if (line.startsWith('### ')) {
                    html += `<h3>${escapeHtml(line.slice(4))}</h3>`;
                } else if (line.startsWith('> ')) {
                    if (!inBlockquote) {
                        inBlockquote = true;
                        html += '<blockquote>';
                    }
                    html += `<p>${escapeHtml(line.slice(2))}</p>`;
                } else if (inBlockquote && line.trim() === '') {
                    inBlockquote = false;
                    html += '</blockquote>';
                } else if (line.startsWith('- ') || line.startsWith('* ')) {
                    if (!inList) {
                        inList = true;
                        html += '<ul>';
                    }
                    html += `<li>${escapeHtml(line.slice(2))}</li>`;
                } else if (line.match(/^\d+\./)) {
                    if (!inList) {
                        inList = true;
                        html += '<ol>';
                    }
                    html += `<li>${escapeHtml(line.replace(/^\d+\.\s*/, ''))}</li>`;
                } else if (inList && line.trim() === '') {
                    inList = false;
                    html += '</ul>';
                } else if (line.startsWith('![')) {
                    const match = line.match(/!\[(.*?)\]\((.*?)\)/);
                    if (match) {
                        html += `<img src="${match[2]}" alt="${escapeHtml(match[1])}" style="max-width:100%;height:auto;">`;
                    }
                } else if (line.startsWith('[')) {
                    const match = line.match(/\[(.*?)\]\((.*?)\)/);
                    if (match) {
                        html += `<a href="${match[2]}">${escapeHtml(match[1])}</a>`;
                    }
                } else if (line.trim() !== '') {
                    html += `<p>${escapeHtml(line)}</p>`;
                }
            });
            
            if (inList) html += '</ul>';
            if (inBlockquote) html += '</blockquote>';
            
            return html;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function createTileElement(tile) {
            const el = document.createElement('div');
            el.className = tile.isPost ? 'tile post-tile' : 'tile';
            el.style.left = `${tile.x}px`;
            el.style.top = `${tile.y}px`;
            el.style.width = `${tile.w}px`;
            el.style.height = `${tile.h}px`;
            el.dataset.id = tile.id;
            
            if (tile.isPost && tile.postIndex < posts.length) {
                el.innerHTML = posts[tile.postIndex].html;
            } else {
                const img = getRandomImage();
                if (img && Math.random() > 0.3) {
                    const imgEl = document.createElement('img');
                    imgEl.src = img.src;
                    imgEl.alt = img.alt || '';
                    el.appendChild(imgEl);
                } else {
                    el.classList.add('color-fill');
                    el.style.backgroundColor = getRandomPastel();
                }
            }
            
            return el;
        }

        function ensureGenerated(targetY) {
            while (generationY < targetY) {
                const isPostStrip = postsLoaded < posts.length && Math.random() < POST_STRIP_CHANCE;
                const { tiles, height } = generateStrip(generationY, isPostStrip);
                
                tiles.forEach(tile => {
                    renderedTiles.set(tile.id, { ...tile, element: null });
                });
                
                generationY += height;
            }
            
            container.style.height = `${generationY + 100}px`;
        }

        function updateVisibleTiles() {
            const scrollTop = viewport.scrollTop;
            const scrollBottom = scrollTop + viewportHeight;
            const renderTop = scrollTop - viewportHeight * BUFFER_TILES;
            const renderBottom = scrollBottom + viewportHeight * BUFFER_TILES;
            
            ensureGenerated(renderBottom + viewportHeight);
            
            renderedTiles.forEach((tile, id) => {
                const tileTop = tile.y;
                const tileBottom = tile.y + tile.h;
                const isVisible = tileBottom > renderTop && tileTop < renderBottom;
                
                if (isVisible && !tile.element) {
                    tile.element = createTileElement(tile);
                    container.appendChild(tile.element);
                } else if (!isVisible && tile.element) {
                    tile.element.remove();
                    tile.element = null;
                }
            });
        }

        function onScroll() {
            requestAnimationFrame(updateVisibleTiles);
        }

        async function init() {
            viewportWidth = viewport.clientWidth;
            viewportHeight = viewport.clientHeight;
            
            await Promise.all([loadImages(), loadPosts()]);
            document.getElementById('loader').style.display = 'none';
            
            // Start generation from top - no special first post
            generationY = 0;
            
            updateVisibleTiles();
            viewport.addEventListener('scroll', onScroll, { passive: true });
        }

        window.addEventListener('resize', () => {
            container.innerHTML = '';
            renderedTiles.clear();
            postsLoaded = 0;
            generationY = 0;
            viewportWidth = viewport.clientWidth;
            viewportHeight = viewport.clientHeight;
            init();
        });

        init();
    </script>
</body>
</html>
