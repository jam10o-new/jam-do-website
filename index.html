<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>jam.do</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #f5f0e8;
            color: #2a2a2a;
            line-height: 1.6;
        }

        #viewport {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
        }

        #grid-container {
            position: relative;
            transform-origin: 0 0;
        }

        .tile {
            position: absolute;
            overflow: hidden;
        }

        .tile img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .tile.color-fill {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .post-tile {
            background: #fffef8;
            padding: 25px;
            overflow-y: auto;
            box-shadow: 0 2px 15px rgba(0,0,0,0.06);
        }

        .post-tile h1 {
            font-size: 1.3rem;
            margin-bottom: 0.8rem;
            font-weight: 600;
        }

        .post-tile h2 {
            font-size: 1.1rem;
            margin: 1rem 0 0.5rem;
            font-weight: 600;
        }

        .post-tile h3 {
            font-size: 0.95rem;
            margin: 0.8rem 0 0.4rem;
            font-weight: 600;
        }

        .post-tile p {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
        }

        .post-tile a {
            color: #c45c3e;
            text-decoration: underline;
            text-underline-offset: 2px;
        }

        .post-tile pre {
            background: #f0ebe3;
            padding: 10px;
            overflow-x: auto;
            margin: 0.8rem 0;
            font-family: monospace;
            font-size: 0.75rem;
        }

        .post-tile code {
            font-family: monospace;
            background: #f0ebe3;
            padding: 2px 5px;
            font-size: 0.85em;
        }

        .post-tile blockquote {
            border-left: 3px solid #c45c3e;
            padding-left: 0.8rem;
            margin: 0.8rem 0;
            color: #555;
        }

        .post-tile ul, .post-tile ol {
            margin: 0.8rem 0 0.8rem 1.5rem;
        }

        .post-tile li {
            margin-bottom: 0.3rem;
        }

        #loader {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.9rem;
            color: #888;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="loader">loading...</div>
    <div id="viewport">
        <div id="grid-container"></div>
    </div>

    <script>
        const warmPastels = [
            '#e8d5c4', '#d4c4b0', '#c9b8a4', '#e6d5c9',
            '#f0e6d8', '#e4d4c0', '#d9c9b6', '#f5ebe0',
            '#e8ddd4', '#ddd0c0', '#f2e6d8', '#e5d9cc',
            '#f0e8e0', '#e8e0d5', '#ddd5c8', '#ede5d8'
        ];

        const ABSOLUTE_MIN_TILE = 180;
        const ABSOLUTE_MAX_TILE = 400;
        const POST_MIN_WIDTH = 300;
        const POST_MAX_WIDTH = 500;
        const POST_MIN_HEIGHT = 250;
        const POST_MAX_HEIGHT = 500;
        const MARGIN = 30;
        const BUFFER_TILES = 3;

        const container = document.getElementById('grid-container');
        const viewport = document.getElementById('viewport');
        
        let posts = [];
        let images = [];
        let renderedTiles = new Map();
        let tileTree = null;
        let nextTileId = 0;
        let postsLoaded = 0;
        let containerHeight = 0;
        let viewportWidth = 0;
        let viewportHeight = 0;

        function getRandomPastel() {
            return warmPastels[Math.floor(Math.random() * warmPastels.length)];
        }

        function getRandomImage() {
            if (images.length === 0) return null;
            return images[Math.floor(Math.random() * images.length)];
        }

        // A tile in our subdivision tree
        class Tile {
            constructor(x, y, w, h, parent = null) {
                this.id = nextTileId++;
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
                this.parent = parent;
                this.children = null;
                this.isPost = false;
                this.postData = null;
                this.content = null;
                this.element = null;
            }

            canSplit() {
                return (this.w > ABSOLUTE_MIN_TILE * 1.5 && this.w > this.h * 0.5) ||
                       (this.h > ABSOLUTE_MIN_TILE * 1.5 && this.h > this.w * 0.5);
            }

            canBePost() {
                return this.w >= POST_MIN_WIDTH && this.w <= POST_MAX_WIDTH &&
                       this.h >= POST_MIN_HEIGHT && this.h <= POST_MAX_HEIGHT &&
                       this.x >= MARGIN && (this.x + this.w) <= (viewportWidth - MARGIN);
            }

            split() {
                if (this.children) return;
                
                const canSplitH = this.w > ABSOLUTE_MIN_TILE * 1.5 && this.w > this.h * 0.5;
                const canSplitV = this.h > ABSOLUTE_MIN_TILE * 1.5 && this.h > this.w * 0.5;
                
                let splitH;
                if (canSplitH && canSplitV) {
                    splitH = this.w > this.h ? Math.random() > 0.3 : Math.random() < 0.3;
                } else {
                    splitH = canSplitH;
                }

                let r1, r2;
                if (splitH) {
                    const minSplit = Math.max(ABSOLUTE_MIN_TILE, this.w * 0.3);
                    const maxSplit = this.w - ABSOLUTE_MIN_TILE;
                    const splitPos = minSplit + Math.random() * (maxSplit - minSplit);
                    r1 = new Tile(this.x, this.y, splitPos, this.h, this);
                    r2 = new Tile(this.x + splitPos, this.y, this.w - splitPos, this.h, this);
                } else {
                    const minSplit = Math.max(ABSOLUTE_MIN_TILE, this.h * 0.3);
                    const maxSplit = this.h - ABSOLUTE_MIN_TILE;
                    const splitPos = minSplit + Math.random() * (maxSplit - minSplit);
                    r1 = new Tile(this.x, this.y, this.w, splitPos, this);
                    r2 = new Tile(this.x, this.y + splitPos, this.w, this.h - splitPos, this);
                }

                this.children = [r1, r2];
                return [r1, r2];
            }
        }

        async function loadImages() {
            try {
                const response = await fetch('images/index.txt');
                if (!response.ok) throw new Error('No image index');
                const text = await response.text();
                const lines = text.split('\n').filter(l => l.trim());
                images = lines.map(line => {
                    const parts = line.split('|');
                    return { src: `images/${parts[0]}`, alt: parts[1] || '' };
                });
            } catch (e) {
                images = [];
            }
        }

        async function loadPosts() {
            try {
                const response = await fetch('posts/index.txt');
                if (!response.ok) throw new Error('No posts');
                const text = await response.text();
                const urls = text.split('\n').filter(u => u.trim());
                
                for (const url of urls) {
                    try {
                        const res = await fetch(`posts/${url}`);
                        const markdown = await res.text();
                        posts.push({
                            url: url,
                            title: url.replace('.md', '').replace(/-/g, ' '),
                            html: renderMarkdown(markdown)
                        });
                    } catch (e) {
                        console.error('Failed to load post:', url);
                    }
                }
            } catch (e) {
                posts = [];
            }
        }

        function renderMarkdown(markdown) {
            const lines = markdown.split('\n');
            let html = '';
            let inList = false;
            let inBlockquote = false;
            let inCode = false;
            
            lines.forEach(line => {
                if (line.startsWith('```')) {
                    inCode = !inCode;
                    html += inCode ? '<pre><code>' : '</code></pre>';
                    return;
                }
                
                if (inCode) {
                    html += line + '\n';
                    return;
                }
                
                if (line.startsWith('# ')) {
                    html += `<h1>${escapeHtml(line.slice(2))}</h1>`;
                } else if (line.startsWith('## ')) {
                    html += `<h2>${escapeHtml(line.slice(3))}</h2>`;
                } else if (line.startsWith('### ')) {
                    html += `<h3>${escapeHtml(line.slice(4))}</h3>`;
                } else if (line.startsWith('> ')) {
                    if (!inBlockquote) {
                        inBlockquote = true;
                        html += '<blockquote>';
                    }
                    html += `<p>${escapeHtml(line.slice(2))}</p>`;
                } else if (inBlockquote && line.trim() === '') {
                    inBlockquote = false;
                    html += '</blockquote>';
                } else if (line.startsWith('- ') || line.startsWith('* ')) {
                    if (!inList) {
                        inList = true;
                        html += '<ul>';
                    }
                    html += `<li>${escapeHtml(line.slice(2))}</li>`;
                } else if (line.match(/^\d+\./)) {
                    if (!inList) {
                        inList = true;
                        html += '<ol>';
                    }
                    html += `<li>${escapeHtml(line.replace(/^\d+\.\s*/, ''))}</li>`;
                } else if (inList && line.trim() === '') {
                    inList = false;
                    html += '</ul>';
                } else if (line.startsWith('![')) {
                    const match = line.match(/!\[(.*?)\]\((.*?)\)/);
                    if (match) {
                        html += `<img src="${match[2]}" alt="${escapeHtml(match[1])}" style="max-width:100%;height:auto;">`;
                    }
                } else if (line.startsWith('[')) {
                    const match = line.match(/\[(.*?)\]\((.*?)\)/);
                    if (match) {
                        html += `<a href="${match[2]}">${escapeHtml(match[1])}</a>`;
                    }
                } else if (line.trim() !== '') {
                    html += `<p>${escapeHtml(line)}</p>`;
                }
            });
            
            if (inList) html += '</ul>';
            if (inBlockquote) html += '</blockquote>';
            
            return html;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function getLeafTiles(tile) {
            if (!tile.children) return [tile];
            return tile.children.flatMap(getLeafTiles);
        }

        function subdivideForViewport() {
            // Create root tile that fills viewport width plus some overflow
            const rootWidth = viewportWidth + ABSOLUTE_MIN_TILE * 2;
            const rootHeight = 3000; // Initial height, will grow
            
            tileTree = new Tile(-ABSOLUTE_MIN_TILE, 0, rootWidth, rootHeight);
            
            // Subdivide until tiles are reasonable size
            let leaves = [tileTree];
            let iterations = 0;
            
            while (iterations < 100) {
                const splittable = leaves.filter(t => t.canSplit());
                if (splittable.length === 0) break;
                
                // Split random tiles
                const toSplit = splittable.filter(() => Math.random() > 0.3);
                if (toSplit.length === 0) toSplit.push(splittable[0]);
                
                toSplit.forEach(t => {
                    const idx = leaves.indexOf(t);
                    const children = t.split();
                    leaves.splice(idx, 1, ...children);
                });
                
                iterations++;
            }
            
            return leaves;
        }

        function tryPlacePost() {
            if (postsLoaded >= posts.length) return false;
            
            const leaves = getLeafTiles(tileTree);
            const candidates = leaves.filter(t => t.canBePost() && !t.isPost && !t.children);
            
            if (candidates.length === 0) return false;
            
            // Find candidate that's reasonably spaced from other posts
            const existingPosts = leaves.filter(t => t.isPost);
            let bestCandidate = null;
            let bestScore = -Infinity;
            
            candidates.forEach(c => {
                let minDist = Infinity;
                existingPosts.forEach(p => {
                    const dy = Math.abs(c.y - p.y);
                    if (dy < minDist) minDist = dy;
                });
                
                const score = minDist + Math.random() * 200;
                if (score > bestScore) {
                    bestScore = score;
                    bestCandidate = c;
                }
            });
            
            if (!bestCandidate) bestCandidate = candidates[0];
            
            bestCandidate.isPost = true;
            bestCandidate.postData = posts[postsLoaded++];
            return true;
        }

        function createTileElement(tile) {
            const el = document.createElement('div');
            el.className = tile.isPost ? 'tile post-tile' : 'tile';
            el.style.left = `${tile.x}px`;
            el.style.top = `${tile.y}px`;
            el.style.width = `${tile.w}px`;
            el.style.height = `${tile.h}px`;
            
            if (tile.isPost) {
                el.innerHTML = tile.postData.html;
            } else {
                const img = getRandomImage();
                if (img && Math.random() > 0.3) {
                    const imgEl = document.createElement('img');
                    imgEl.src = img.src;
                    imgEl.alt = img.alt || '';
                    el.appendChild(imgEl);
                } else {
                    el.classList.add('color-fill');
                    el.style.backgroundColor = getRandomPastel();
                }
            }
            
            return el;
        }

        function updateVisibleTiles() {
            const scrollTop = viewport.scrollTop;
            const scrollBottom = scrollTop + viewportHeight;
            const renderTop = scrollTop - viewportHeight * BUFFER_TILES;
            const renderBottom = scrollBottom + viewportHeight * BUFFER_TILES;
            
            const leaves = getLeafTiles(tileTree);
            
            // Check if we need to grow the tree
            const maxY = Math.max(...leaves.map(t => t.y + t.h));
            if (renderBottom > maxY - viewportHeight) {
                growTree();
            }
            
            // Render visible tiles
            leaves.forEach(tile => {
                const tileTop = tile.y;
                const tileBottom = tile.y + tile.h;
                const isVisible = tileBottom > renderTop && tileTop < renderBottom;
                
                if (isVisible && !tile.element) {
                    tile.element = createTileElement(tile);
                    container.appendChild(tile.element);
                    renderedTiles.set(tile.id, tile);
                } else if (!isVisible && tile.element) {
                    tile.element.remove();
                    tile.element = null;
                    renderedTiles.delete(tile.id);
                }
            });
            
            // Update container height
            const newHeight = Math.max(...leaves.map(t => t.y + t.h)) + MARGIN;
            if (newHeight > containerHeight) {
                containerHeight = newHeight;
                container.style.height = `${containerHeight}px`;
            }
        }

        function growTree() {
            // Extend the tree downward by splitting bottom tiles
            const leaves = getLeafTiles(tileTree);
            const bottomTiles = leaves.filter(t => {
                const maxLeafY = Math.max(...leaves.map(l => l.y + l.h));
                return (t.y + t.h) > maxLeafY - ABSOLUTE_MAX_TILE * 2;
            });
            
            // Try to place a post before growing
            if (postsLoaded < posts.length) {
                tryPlacePost();
            }
            
            // Split some bottom tiles vertically to extend
            bottomTiles.forEach(t => {
                if (t.h > ABSOLUTE_MIN_TILE * 1.5 && Math.random() > 0.5) {
                    t.split();
                }
            });
        }

        function onScroll() {
            requestAnimationFrame(updateVisibleTiles);
        }

        async function init() {
            viewportWidth = viewport.clientWidth;
            viewportHeight = viewport.clientHeight;
            
            await Promise.all([loadImages(), loadPosts()]);
            document.getElementById('loader').style.display = 'none';
            
            // Initial subdivision
            subdivideForViewport();
            
            // Place initial posts
            for (let i = 0; i < Math.min(2, posts.length); i++) {
                tryPlacePost();
            }
            
            // Initial render
            updateVisibleTiles();
            
            // Scroll handler
            viewport.addEventListener('scroll', onScroll, { passive: true });
        }

        window.addEventListener('resize', () => {
            // Clear and rebuild on resize
            container.innerHTML = '';
            renderedTiles.clear();
            postsLoaded = 0;
            containerHeight = 0;
            viewportWidth = viewport.clientWidth;
            viewportHeight = viewport.clientHeight;
            init();
        });

        init();
    </script>
</body>
</html>
