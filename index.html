<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>jam.do</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #f5f0e8;
            color: #2a2a2a;
            line-height: 1.6;
        }

        #viewport {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
        }

        #grid-container {
            position: relative;
            transform-origin: 0 0;
        }

        .tile {
            position: absolute;
            overflow: hidden;
        }

        .tile img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .tile.color-fill {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .post-tile {
            background: #fffef8;
            padding: 25px;
            overflow-y: auto;
            box-shadow: 0 2px 15px rgba(0,0,0,0.06);
        }

        .post-tile h1 {
            font-size: 1.3rem;
            margin-bottom: 0.8rem;
            font-weight: 600;
        }

        .post-tile h2 {
            font-size: 1.1rem;
            margin: 1rem 0 0.5rem;
            font-weight: 600;
        }

        .post-tile h3 {
            font-size: 0.95rem;
            margin: 0.8rem 0 0.4rem;
            font-weight: 600;
        }

        .post-tile p {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
        }

        .post-tile a {
            color: #c45c3e;
            text-decoration: underline;
            text-underline-offset: 2px;
        }

        .post-tile pre {
            background: #f0ebe3;
            padding: 10px;
            overflow-x: auto;
            margin: 0.8rem 0;
            font-family: monospace;
            font-size: 0.75rem;
        }

        .post-tile code {
            font-family: monospace;
            background: #f0ebe3;
            padding: 2px 5px;
            font-size: 0.85em;
        }

        .post-tile blockquote {
            border-left: 3px solid #c45c3e;
            padding-left: 0.8rem;
            margin: 0.8rem 0;
            color: #555;
        }

        .post-tile ul, .post-tile ol {
            margin: 0.8rem 0 0.8rem 1.5rem;
        }

        .post-tile li {
            margin-bottom: 0.3rem;
        }

        #loader {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.9rem;
            color: #888;
            z-index: 100;
        }

        #debug {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: #0f0;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            z-index: 1000;
            max-width: 300px;
            max-height: 200px;
            overflow: auto;
            display: none; /* Hidden by default - toggle in dev tools */
        }
    </style>
</head>
<body>
    <div id="loader">loading...</div>
    <div id="debug"></div>
    <div id="viewport">
        <div id="grid-container"></div>
    </div>

    <script>
        const warmPastels = [
            '#e8d5c4', '#d4c4b0', '#c9b8a4', '#e6d5c9',
            '#f0e6d8', '#e4d4c0', '#d9c9b6', '#f5ebe0',
            '#e8ddd4', '#ddd0c0', '#f2e6d8', '#e5d9cc',
            '#f0e8e0', '#e8e0d5', '#ddd5c8', '#ede5d8'
        ];

        const ABSOLUTE_MIN_TILE = 200;
        const ABSOLUTE_MAX_TILE = 4000;
        const POST_MIN_WIDTH = 600;
        const POST_MAX_WIDTH = 1200;
        const POST_MIN_HEIGHT = 400;
        const POST_MAX_HEIGHT = 800;
        const MARGIN = 30;
        const BUFFER_TILES = 2;
        const POST_CHANCE = 0.15; // Chance for a tile to become a post slot

        const container = document.getElementById('grid-container');
        const viewport = document.getElementById('viewport');
        const debug = document.getElementById('debug');
        
        let posts = [];
        let images = [];
        let renderedTiles = new Map();
        let postsLoaded = 0;
        let lastPostY = 0;
        let generationY = 0; // How far down we've generated
        let viewportWidth = 0;
        let viewportHeight = 0;

        function log(msg) {
            debug.innerHTML += msg + '<br>';
            debug.scrollTop = debug.scrollHeight;
        }

        function getRandomPastel() {
            return warmPastels[Math.floor(Math.random() * warmPastels.length)];
        }

        function getRandomImage() {
            if (images.length === 0) return null;
            return images[Math.floor(Math.random() * images.length)];
        }

        function getRandomPostSize() {
            const w = POST_MIN_WIDTH + Math.random() * (POST_MAX_WIDTH - POST_MIN_WIDTH);
            const h = POST_MIN_HEIGHT + Math.random() * (POST_MAX_HEIGHT - POST_MIN_HEIGHT);
            return { w, h };
        }

        // Generate a strip of tiles at the given Y position
        // Returns array of tile descriptors (not yet rendered)
        function generateTileStrip(startY) {
            const tiles = [];
            let currentX = 0;
            
            while (currentX < viewportWidth) {
                const remaining = viewportWidth - currentX;
                
                // Decide if this should be a post slot
                const shouldBePost = postsLoaded < posts.length && 
                                    Math.random() < POST_CHANCE &&
                                    remaining >= POST_MIN_WIDTH &&
                                    currentX >= MARGIN;
                
                if (shouldBePost) {
                    const size = getRandomPostSize();
                    const w = Math.min(size.w, remaining - MARGIN);
                    const h = size.h;
                    
                    if (w >= POST_MIN_WIDTH && currentX + w <= viewportWidth - MARGIN) {
                        tiles.push({
                            x: currentX,
                            y: startY,
                            w: w,
                            h: h,
                            isPost: true,
                            postIndex: postsLoaded++,
                            id: Math.random().toString(36).substr(2, 9)
                        });
                        currentX += w;
                        lastPostY = startY;
                        continue;
                    }
                }
                
                // Regular tile with random size
                const maxW = Math.min(remaining, ABSOLUTE_MAX_TILE);
                const minW = Math.min(ABSOLUTE_MIN_TILE, remaining);
                const w = minW + Math.random() * (maxW - minW);
                const h = ABSOLUTE_MIN_TILE + Math.random() * (ABSOLUTE_MAX_TILE - ABSOLUTE_MIN_TILE);
                
                tiles.push({
                    x: currentX,
                    y: startY,
                    w: w,
                    h: h,
                    isPost: false,
                    id: Math.random().toString(36).substr(2, 9)
                });
                
                currentX += w;
            }
            
            // Subdivide tall tiles vertically to create more horizontal strips
            const finalTiles = [];
            tiles.forEach(tile => {
                if (tile.isPost) {
                    finalTiles.push(tile);
                } else if (tile.h > ABSOLUTE_MIN_TILE * 2 && Math.random() > 0.5) {
                    // Split vertically
                    const splitH = ABSOLUTE_MIN_TILE + Math.random() * (tile.h - ABSOLUTE_MIN_TILE * 2);
                    finalTiles.push({
                        ...tile,
                        h: splitH,
                        id: tile.id + 'a'
                    });
                    finalTiles.push({
                        ...tile,
                        y: tile.y + splitH,
                        h: tile.h - splitH,
                        id: tile.id + 'b'
                    });
                } else {
                    finalTiles.push(tile);
                }
            });
            
            return finalTiles;
        }

        async function loadImages() {
            try {
                const response = await fetch('images/index.txt');
                if (!response.ok) throw new Error('No image index');
                const text = await response.text();
                const lines = text.split('\n').filter(l => l.trim());
                images = lines.map(line => {
                    const parts = line.split('|');
                    return { src: `images/${parts[0]}`, alt: parts[1] || '' };
                });
            } catch (e) {
                images = [];
            }
        }

        async function loadPosts() {
            try {
                const response = await fetch('posts/index.txt');
                if (!response.ok) throw new Error('No posts');
                const text = await response.text();
                const urls = text.split('\n').filter(u => u.trim());
                
                for (const url of urls) {
                    try {
                        const res = await fetch(`posts/${url}`);
                        const markdown = await res.text();
                        posts.push({
                            url: url,
                            title: url.replace('.md', '').replace(/-/g, ' '),
                            html: renderMarkdown(markdown)
                        });
                    } catch (e) {
                        console.error('Failed to load post:', url);
                    }
                }
            } catch (e) {
                posts = [];
            }
        }

        function renderMarkdown(markdown) {
            const lines = markdown.split('\n');
            let html = '';
            let inList = false;
            let inBlockquote = false;
            let inCode = false;
            
            lines.forEach(line => {
                if (line.startsWith('```')) {
                    inCode = !inCode;
                    html += inCode ? '<pre><code>' : '</code></pre>';
                    return;
                }
                
                if (inCode) {
                    html += line + '\n';
                    return;
                }
                
                if (line.startsWith('# ')) {
                    html += `<h1>${escapeHtml(line.slice(2))}</h1>`;
                } else if (line.startsWith('## ')) {
                    html += `<h2>${escapeHtml(line.slice(3))}</h2>`;
                } else if (line.startsWith('### ')) {
                    html += `<h3>${escapeHtml(line.slice(4))}</h3>`;
                } else if (line.startsWith('> ')) {
                    if (!inBlockquote) {
                        inBlockquote = true;
                        html += '<blockquote>';
                    }
                    html += `<p>${escapeHtml(line.slice(2))}</p>`;
                } else if (inBlockquote && line.trim() === '') {
                    inBlockquote = false;
                    html += '</blockquote>';
                } else if (line.startsWith('- ') || line.startsWith('* ')) {
                    if (!inList) {
                        inList = true;
                        html += '<ul>';
                    }
                    html += `<li>${escapeHtml(line.slice(2))}</li>`;
                } else if (line.match(/^\d+\./)) {
                    if (!inList) {
                        inList = true;
                        html += '<ol>';
                    }
                    html += `<li>${escapeHtml(line.replace(/^\d+\.\s*/, ''))}</li>`;
                } else if (inList && line.trim() === '') {
                    inList = false;
                    html += '</ul>';
                } else if (line.startsWith('![')) {
                    const match = line.match(/!\[(.*?)\]\((.*?)\)/);
                    if (match) {
                        html += `<img src="${match[2]}" alt="${escapeHtml(match[1])}" style="max-width:100%;height:auto;">`;
                    }
                } else if (line.startsWith('[')) {
                    const match = line.match(/\[(.*?)\]\((.*?)\)/);
                    if (match) {
                        html += `<a href="${match[2]}">${escapeHtml(match[1])}</a>`;
                    }
                } else if (line.trim() !== '') {
                    html += `<p>${escapeHtml(line)}</p>`;
                }
            });
            
            if (inList) html += '</ul>';
            if (inBlockquote) html += '</blockquote>';
            
            return html;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function createTileElement(tile) {
            const el = document.createElement('div');
            el.className = tile.isPost ? 'tile post-tile' : 'tile';
            el.style.left = `${tile.x}px`;
            el.style.top = `${tile.y}px`;
            el.style.width = `${tile.w}px`;
            el.style.height = `${tile.h}px`;
            el.dataset.id = tile.id;
            
            if (tile.isPost && tile.postIndex < posts.length) {
                el.innerHTML = posts[tile.postIndex].html;
            } else {
                const img = getRandomImage();
                if (img && Math.random() > 0.3) {
                    const imgEl = document.createElement('img');
                    imgEl.src = img.src;
                    imgEl.alt = img.alt || '';
                    el.appendChild(imgEl);
                } else {
                    el.classList.add('color-fill');
                    el.style.backgroundColor = getRandomPastel();
                }
            }
            
            return el;
        }

        // Generate content down to targetY
        function ensureGenerated(targetY) {
            while (generationY < targetY) {
                const stripHeight = ABSOLUTE_MIN_TILE + Math.random() * 200;
                const tiles = generateTileStrip(generationY);
                
                tiles.forEach(tile => {
                    // Store for later rendering
                    renderedTiles.set(tile.id, { ...tile, element: null });
                });
                
                generationY += stripHeight;
            }
            
            // Update container height
            container.style.height = `${generationY + 100}px`;
        }

        function updateVisibleTiles() {
            const scrollTop = viewport.scrollTop;
            const scrollBottom = scrollTop + viewportHeight;
            const renderTop = scrollTop - viewportHeight * BUFFER_TILES;
            const renderBottom = scrollBottom + viewportHeight * BUFFER_TILES;
            
            // Generate more if needed
            ensureGenerated(renderBottom + viewportHeight);
            
            // Render visible, remove off-screen
            renderedTiles.forEach((tile, id) => {
                const tileTop = tile.y;
                const tileBottom = tile.y + tile.h;
                const isVisible = tileBottom > renderTop && tileTop < renderBottom;
                
                if (isVisible && !tile.element) {
                    tile.element = createTileElement(tile);
                    container.appendChild(tile.element);
                } else if (!isVisible && tile.element) {
                    tile.element.remove();
                    tile.element = null;
                }
            });
        }

        function onScroll() {
            requestAnimationFrame(updateVisibleTiles);
        }

        async function init() {
            viewportWidth = viewport.clientWidth;
            viewportHeight = viewport.clientHeight;
            
            await Promise.all([loadImages(), loadPosts()]);
            document.getElementById('loader').style.display = 'none';
            
            // Start with first post at top
            if (posts.length > 0) {
                const size = getRandomPostSize();
                const x = MARGIN + Math.random() * (viewportWidth - size.w - MARGIN * 2);
                const firstPost = {
                    x: x,
                    y: 50,
                    w: size.w,
                    h: size.h,
                    isPost: true,
                    postIndex: postsLoaded++,
                    id: 'first-post'
                };
                renderedTiles.set(firstPost.id, { ...firstPost, element: null });
                generationY = firstPost.y + firstPost.h + 100;
                lastPostY = firstPost.y;
            } else {
                generationY = 0;
            }
            
            updateVisibleTiles();
            viewport.addEventListener('scroll', onScroll, { passive: true });
        }

        window.addEventListener('resize', () => {
            container.innerHTML = '';
            renderedTiles.clear();
            postsLoaded = 0;
            generationY = 0;
            viewportWidth = viewport.clientWidth;
            viewportHeight = viewport.clientHeight;
            init();
        });

        init();
    </script>
</body>
</html>
