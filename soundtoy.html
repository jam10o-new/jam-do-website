<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Stylus Synth DAW</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#0f0f0f;color:#eee;font-family:monospace}
  .row{display:flex;height:100%}
  #sidebar{width:340px;background:#111;padding:12px;box-sizing:border-box;display:flex;flex-direction:column;gap:10px;overflow-y:auto}
  #main{flex:1;display:flex;flex-direction:column;min-width:0}
  #canvasWrap{flex:1;padding:12px;box-sizing:border-box;min-height:0}
  #draw{width:100%;height:100%;display:block}
  #footer{height:320px;background:#0b0b0b;border-top:1px solid #222;padding:8px;box-sizing:border-box;display:flex;flex-direction:column;gap:8px}
  button{background:#1a1a1a;border:1px solid #333;color:#ddd;padding:6px 8px;cursor:pointer}
  button:disabled{opacity:0.5;cursor:not-allowed}
  .mono{font-family:monospace;font-size:12px;color:#ddd}
  .small{font-size:11px;color:#aaa}
  .section{padding:6px;border:1px solid #222;background:#0b0b0b}
  label{font-size:12px;display:block;margin-bottom:4px}
  select,input[type=color]{width:100%;box-sizing:border-box}
  .list{max-height:150px;overflow:auto;margin-top:6px}
  .item{display:flex;gap:6px;align-items:center;margin:4px 0}
  .item button{padding:2px 6px}
  #timelineContainer{flex:1;overflow:auto;border:1px solid #222;position:relative;background:#050505;min-height:160px}
  #timelineCanvas{height:160px;display:block;background:#050505}
  .global-controls{display:flex;gap:8px;align-items:center;margin-top:4px}
  .timeline-controls{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-bottom:4px}
  .timeline-controls input[type=number]{width:80px;background:#1a1a1a;border:1px solid #333;color:#ddd;padding:2px 4px}
  .live-indicator{color:#ff6b6b;font-size:10px;animation:pulse 1s infinite}
  @keyframes pulse{0%{opacity:1}50%{opacity:0.5}100%{opacity:1}}
  .file-input-ui{display:flex;flex-direction:column;gap:4px;margin-top:6px}
  .file-input-ui input[type=file]{display:none}
  .file-input-ui button{font-size:11px;padding:4px 6px}
  .progress-bar{height:3px;background:#333;width:100%;margin-top:2px}
  .progress-bar-inner{height:100%;background:#4CAF50;width:0%;transition:width 0.1s}
  .connection-item{display:flex;justify-content:space-between;align-items:center;padding:6px;border-bottom:1px solid #222}
  .connection-label{flex:1;font-size:11px}
  .connection-controls{display:flex;gap:4px}
  .recording-indicator{color:#ff6b6b;font-size:10px;animation:pulse 0.5s infinite}
  
  /* Mobile responsive styles */
  @media (max-width: 768px) {
    .row {
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    
    #sidebar {
      width: 100%;
      height: 40vh;
      min-height: 40vh;
      overflow-y: auto;
      padding: 8px;
    }
    
    #main {
      height: 60vh;
      min-height: 60vh;
    }
    
    #canvasWrap {
      padding: 4px;
      min-height: 0;
      flex: 1;
    }
    
    #footer {
      height: 160px;
      min-height: 160px;
      padding: 4px;
    }
    
    .timeline-controls {
      gap: 6px;
      flex-wrap: wrap;
    }
    
    .timeline-controls input[type=number] {
      width: 60px;
    }
    
    #canvasTimeSlider {
      width: 120px;
    }
    
    .global-controls {
      gap: 4px;
    }
    
    button {
      padding: 8px 10px; /* Larger touch targets */
    }
    
    .section {
      padding: 4px;
    }
    
    .mono {
      font-size: 11px;
    }
    
    /* Hide non-essential elements on mobile */
    .global-controls .mono.small:not(:first-child) {
      display: none;
    }
  }
  
  /* Desktop-only styles */
  @media (min-width: 769px) {
    /* Ensure desktop layout remains unchanged */
    .row {
      flex-direction: row;
    }
    
    #sidebar {
      width: 340px;
      height: 100%;
    }
    
    #main {
      height: 100%;
    }
  }
</style>
</head>
<body>
<div class="row">
  <div id="sidebar">
    <div class="section">
      <div class="mono">AUDIO NODES</div>
      <div style="display:flex;gap:6px;margin-top:6px;flex-wrap:wrap">
        <button data-mk="osc">Osc</button>
        <button data-mk="gain">Gain</button>
        <button data-mk="filter">Filter</button>
        <button data-mk="delay">Delay</button>
        <button data-mk="pan">Pan</button>
        <button data-mk="compressor">Comp</button>
        <button data-mk="input">Input</button>
      </div>
      <div class="list" id="nodeList"></div>
    </div>

    <div class="section">
      <div class="mono">CONNECTIONS</div>
      <div class="list" id="connectionList"></div>
    </div>

    <div class="section">
      <div class="mono">SIGNAL GENERATORS</div>
      <div style="display:flex;gap:6px;margin-top:6px;flex-wrap:wrap">
        <button data-sig="sine">Sine</button>
        <button data-sig="saw">Saw</button>
        <button data-sig="tri">Tri</button>
        <button data-sig="square">Square</button>
        <button data-sig="noise">Noise</button>
      </div>
      <div class="list" id="sigList"></div>
    </div>

    <div class="section">
      <div class="mono">CANVASES <span id="liveIndicator" class="live-indicator" style="display:none">‚óè LIVE</span></div>
      <div style="display:flex;gap:6px;margin-top:6px">
        <button id="newCanvas">+ New</button>
        <button id="delCanvas">Del</button>
        <button id="clearCanvas">Clear</button>
      </div>
      <label style="margin-top:8px">Color <input id="canvasColor" type="color" value="#9ad1ff"/></label>
      <div class="list" id="canvasList"></div>
      <label>X axis: <select id="xBind"></select></label>
      <label>Y axis: <select id="yBind"></select></label>
    </div>

    <div class="section">
      <div class="mono">INFO</div>
      <div id="infoBox" class="mono small">idle</div>
    </div>

    <div class="section">
      <div class="mono">EXPORT / IMPORT</div>
      <div style="display:flex;gap:6px;margin-top:6px">
        <button id="exportBtn">Export</button>
        <button id="importBtn">Import</button>
        <input type="file" id="importFile" accept=".json" style="display:none"/>
      </div>
    </div>
  </div>

  <div id="main">
    <div id="canvasWrap"><canvas id="draw"></canvas></div>

    <div id="footer">
      <div class="timeline-controls">
        <label class="mono small">Canvas <span id="activeCanvasName" style="color:#9ad1ff">‚Äî</span></label>
        <label class="mono small">Len <input id="canvasDuration" type="number" value="10000" min="100">ms</label>
        <label><input id="canvasLoop" type="checkbox" checked> Loop</label>
        <label><input id="canvasMute" type="checkbox"> Mute</label>
        <label class="mono small">Speed <input id="canvasSpeed" type="number" value="1" step="0.01" min="0.01"></label>
        <span class="mono small">Time <span id="canvasTime">0.000s</span></span>
        <input id="canvasTimeSlider" type="range" min="0" max="10000" value="0" style="width:160px"/>
        <div style="flex:1"></div>
        <div class="mono small">Zoom: <input id="zoomRange" type="range" min="0.02" max="0.25" step="0.01" value="0.05" style="width:120px"></div>
      </div>

      <div id="timelineContainer"><canvas id="timelineCanvas" height="160"></canvas></div>

      <div class="global-controls">
        <button id="playAll">‚ñ∂</button>
        <button id="pauseAll">‚ñê‚ñê</button>
        <button id="stopAll">‚ñ†</button>
      </div>
    </div>
  </div>
</div>

<script>
/* Fixed single-file DAW ‚Äî unified timeline with enhanced features:
   - Mobile responsive layout with proper touch handling
   - Logarithmic scaling for frequency parameters with grid lines
   - Audio input nodes (file/mic) with loopable buffers
   - Connection view with disconnect functionality
   - Smooth parameter interpolation
*/

const TIMESTEP = 16;
const SMOOTH_TIME_CONSTANT = 0.02;

const drawCanvas = document.getElementById('draw');
const drawCtx = drawCanvas.getContext('2d');
const timelineCanvas = document.getElementById('timelineCanvas');
const timelineContainer = document.getElementById('timelineContainer');
const infoBox = document.getElementById('infoBox');
const liveIndicator = document.getElementById('liveIndicator');

let ratio = window.devicePixelRatio || 1;
let isMobile = window.innerWidth <= 768;

// State
let canvases = [];
let canvasCounter = 0;
let activeCanvasId = null;
let drawing = false;
let stroke = [];
let strokeStartTime = 0;
let gestureOffsetMs = 0;

// Audio graph containers
const audioNodes = new Map();
let nodeCounter = 1;
const connections = [];

// Signals
const signalGens = new Map();

function logInfo(s){ infoBox.textContent = s; }

// ---------------------- Mobile Detection & Touch Handling ----------------------
function handleTouchEvent(ev) {
  // Prevent default touch behaviors that interfere with drawing
  ev.preventDefault();
  
  if (ev.type === 'touchstart' || ev.type === 'touchmove') {
    // Convert touch to mouse event for compatibility
    const touch = ev.touches[0];
    const mouseEv = new MouseEvent(ev.type.replace('touch', 'mouse'), {
      clientX: touch.clientX,
      clientY: touch.clientY,
      buttons: 1
    });
    
    if (ev.type === 'touchstart') {
      drawCanvas.dispatchEvent(new PointerEvent('pointerdown', {
        clientX: touch.clientX,
        clientY: touch.clientY,
        pointerId: 1,
        pointerType: 'touch',
        isPrimary: true
      }));
    } else if (ev.type === 'touchmove') {
      drawCanvas.dispatchEvent(new PointerEvent('pointermove', {
        clientX: touch.clientX,
        clientY: touch.clientY,
        pointerId: 1,
        pointerType: 'touch',
        isPrimary: true
      }));
    }
  } else if (ev.type === 'touchend') {
    drawCanvas.dispatchEvent(new PointerEvent('pointerup', {
      pointerId: 1,
      pointerType: 'touch',
      isPrimary: true
    }));
  }
}

// Add touch event listeners for mobile
if ('ontouchstart' in window) {
  drawCanvas.addEventListener('touchstart', handleTouchEvent, { passive: false });
  drawCanvas.addEventListener('touchmove', handleTouchEvent, { passive: false });
  drawCanvas.addEventListener('touchend', handleTouchEvent, { passive: false });
  drawCanvas.addEventListener('touchcancel', handleTouchEvent, { passive: false });
}

// ---------------------- Utilities ----------------------
function uid(prefix='id'){ return prefix + Math.random().toString(16).slice(2,9); }
function getCanvasById(id){ return canvases.find(c=>c.id===id); }

// ---------------------- Enhanced Audio node helpers ----------------------
const AudioContextClass = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContextClass();

// Smooth parameter application using setTargetAtTime
function applySmoothValue(param, value, audioCtx) {
  if (param && typeof param.setTargetAtTime === 'function') {
    param.setTargetAtTime(value, audioCtx.currentTime, SMOOTH_TIME_CONSTANT);
    return true;
  } else if (param && typeof param.setValueAtTime === 'function') {
    param.setValueAtTime(value, audioCtx.currentTime);
    return true;
  }
  return false;
}

function makeAudioNode(type){
  let node = null;
  let wrapper = null;
  
  try{
    switch(type){
      case 'osc': 
        node = audioCtx.createOscillator(); 
        node.type='sine'; 
        node.start(); 
        break;
      case 'gain': 
        node = audioCtx.createGain(); 
        break;
      case 'filter': 
        node = audioCtx.createBiquadFilter(); 
        break;
      case 'delay': 
        node = audioCtx.createDelay(); 
        break;
      case 'pan': 
        node = audioCtx.createStereoPanner(); 
        break;
      case 'compressor': 
        node = audioCtx.createDynamicsCompressor(); 
        break;
      case 'input':
        // Create a wrapper for input nodes
        wrapper = {
          type: 'input',
          source: null,
          gainNode: audioCtx.createGain(),
          playbackRate: audioCtx.createGain(),
          isPlaying: false,
          isRecording: false,
          isLooping: false,
          isMicrophone: false,
          buffer: null,
          recordedChunks: [],
          mediaRecorder: null,
          startTime: 0,
          offset: 0,
          duration: 0,
          stream: null
        };
        // The actual node is the gain node
        node = wrapper.gainNode;
        break;
    }
  }catch(e){
    logInfo('audio node creation failed: '+e.message); return null;
  }
  
  if(!node && !wrapper) return null;
  
  const id = 'N'+(nodeCounter++);
  audioNodes.set(id, {node, type, wrapper});
  rebuildNodeList();
  rebuildAllBindings();
  rebuildConnectionList();
  return id;
}

function connectNode(srcId, destId){
  const srcEntry = audioNodes.get(srcId);
  if (!srcEntry) return;
  
  const src = srcEntry.wrapper ? srcEntry.wrapper.gainNode : srcEntry.node;
  const target = destId === 'dest' ? audioCtx.destination : audioNodes.get(destId)?.node;
  
  if(!src || !target) return;
  try{
    src.connect(target);
    
    // Check if connection already exists
    const existingConn = connections.find(c => c.source === srcId && c.target === destId);
    if (!existingConn) {
      connections.push({source:srcId, target:destId});
      rebuildConnectionList();
      rebuildNodeList();
      logInfo(srcId+' ‚Üí '+destId);
    } else {
      logInfo('Connection already exists');
    }
  }catch(e){ logInfo('connect failed: '+e.message); }
}

function disconnectConnection(conn){
  try{
    const srcEntry = audioNodes.get(conn.source);
    const src = srcEntry?.wrapper ? srcEntry.wrapper.gainNode : srcEntry?.node;
    const tgt = conn.target==='dest' ? audioCtx.destination : audioNodes.get(conn.target)?.node;
    if(src && tgt) src.disconnect(tgt);
  }catch(e){}
  const i = connections.indexOf(conn);
  if(i>-1) connections.splice(i,1);
  rebuildConnectionList();
  rebuildNodeList();
}

// ---------------------- Enhanced Bindable param helpers ----------------------
function getNumericParams(nodeObj, wrapper){
  const out = [];
  const candidates = ['frequency','detune','gain','Q','delayTime','pan','threshold','knee','ratio','attack','release','offset','playbackRate','volume'];
  
  // If it's an input node wrapper, add its special params
  if (wrapper && wrapper.type === 'input') {
    candidates.push('volume', 'playbackRate', 'position');
  }
  
  for(const k of candidates){
    let value = null;
    let isAudioParam = false;
    
    if (wrapper && wrapper.type === 'input') {
      // Handle input node special parameters
      if (k === 'volume' && wrapper.gainNode && wrapper.gainNode.gain) {
        value = wrapper.gainNode.gain;
        isAudioParam = true;
      } else if (k === 'playbackRate' && wrapper.playbackRate) {
        value = wrapper.playbackRate.gain;
        isAudioParam = true;
      } else if (k === 'position') {
        value = wrapper.offset || 0;
        isAudioParam = false;
      }
    } else if(k in nodeObj){
      value = nodeObj[k];
      isAudioParam = (typeof value === 'object' && value !== null && 'value' in value);
    }
    
    if(value !== null) {
      out.push({key:k, label:k, isAudioParam});
    }
  }
  
  return out;
}

function getSignalGenParams(sig){
  return [
    {key: 'freq', label: 'freq'},
    {key: 'amp', label: 'amp'},
    {key: 'bias', label: 'bias'}
  ];
}

// ---------------------- Logarithmic Scaling Functions ----------------------
// Convert normalized value (0-1) to logarithmic value within range
function normToLog(norm, min, max) {
  // Handle edge cases
  if (norm <= 0) return min;
  if (norm >= 1) return max;
  
  // Logarithmic scaling: norm = log(value/min) / log(max/min)
  // So: value = min * (max/min)^norm
  return min * Math.pow(max / min, norm);
}

// Convert logarithmic value back to normalized value
function logToNorm(value, min, max) {
  if (value <= min) return 0;
  if (value >= max) return 1;
  return Math.log(value / min) / Math.log(max / min);
}

// Generate logarithmic grid lines
function generateLogGridLines(min, max, base = 10) {
  const lines = [];
  const logMin = Math.log(min) / Math.log(base);
  const logMax = Math.log(max) / Math.log(base);
  
  // Major lines at powers of the base
  for (let i = Math.floor(logMin); i <= Math.ceil(logMax); i++) {
    const value = Math.pow(base, i);
    if (value >= min && value <= max) {
      lines.push({value, isMajor: true});
      
      // Add minor lines between major lines (2, 3, 4, 5, 6, 7, 8, 9)
      if (i < Math.ceil(logMax)) {
        for (let j = 2; j < base; j++) {
          const minorValue = value * j;
          if (minorValue <= max) {
            lines.push({value: minorValue, isMajor: false});
          }
        }
      }
    }
  }
  
  return lines.sort((a, b) => a.value - b.value);
}

function convertPointToParam(norm, pname){
  // Logarithmic scaling for frequency parameters
  if (pname.match(/frequency/)) {
    const minFreq = 20;   // 20 Hz
    const maxFreq = 20000; // 20 kHz (human hearing range)
    return normToLog(norm, minFreq, maxFreq);
  }
  
  // Logarithmic scaling for gain (dB)
  if (pname === 'gain') {
    const minGain = 0.001; // -60 dB
    const maxGain = 2;     // +6 dB
    return normToLog(norm, minGain, maxGain);
  }
  
  // Linear scaling for other parameters
  if(pname.match(/delayTime|offset/)) return 20 + norm * (2000 - 20);
  if(pname.match(/pan|ratio|Q/)){
    if(pname==='pan') return -1 + norm*2;
    if(pname==='ratio') return 1 + norm*19;
    if(pname==='Q') return 0.1 + norm*30;
    return norm;
  }
  if(pname.match(/detune|threshold|knee|attack|release/)){
    if(pname==='detune') return -1200 + norm*2400;
    if(pname==='threshold') return -100 + norm*100;
    if(pname==='knee') return norm*40;
    if(pname==='attack' || pname==='release') return norm;
    return norm;
  }
  // Signal generator parameters
  if(pname === 'freq') {
    const minFreq = 0.1;
    const maxFreq = 20;
    return normToLog(norm, minFreq, maxFreq);
  }
  if(pname === 'amp') return norm * 5;
  if(pname === 'bias') return -2 + norm * 4;
  // Input node parameters
  if(pname === 'volume') {
    const minVol = 0.001;
    const maxVol = 2;
    return normToLog(norm, minVol, maxVol);
  }
  if(pname === 'playbackRate') return 0.25 + norm * 3;
  if(pname === 'position') return norm;
  return norm;
}

function applyValueToTarget(target, value){
  if(!target) return;
  
  const parts = target.split(':');
  if(parts.length < 2) return;
  
  const type = parts[0];
  const id = parts[1];
  const param = parts[2];
  
  switch(type){
    case 'canvas':
      const c = getCanvasById(id);
      if(!c) return;
      if(param === 'speed') c.speed = Math.max(0.001, Number(value) || 0.001);
      if(param === 'duration'){
        const dur = Math.max(100, Math.round(Number(value) || c.duration));
        c.duration = dur;
        if(c.currentTime > c.duration) c.currentTime = c.duration;
        updateTimelineSize();
      }
      break;
      
    case 'node':
      const nodeEntry = audioNodes.get(id);
      if(!nodeEntry) return;
      
      // Handle input node special parameters
      if (nodeEntry.wrapper && nodeEntry.wrapper.type === 'input') {
        const wrapper = nodeEntry.wrapper;
        if (param === 'volume' && wrapper.gainNode && wrapper.gainNode.gain) {
          applySmoothValue(wrapper.gainNode.gain, value, audioCtx);
        } else if (param === 'playbackRate' && wrapper.playbackRate && wrapper.playbackRate.gain) {
          applySmoothValue(wrapper.playbackRate.gain, value, audioCtx);
        } else if (param === 'position' && wrapper.buffer) {
          // Seek to position in audio file
          wrapper.offset = Math.max(0, Math.min(1, value)) * wrapper.duration;
          if (wrapper.isPlaying && wrapper.source) {
            stopInputPlayback(wrapper);
            startInputPlayback(wrapper);
          }
        }
        return;
      }
      
      const node = nodeEntry.node;
      const prop = node[param];
      if (prop) {
        applySmoothValue(prop, value, audioCtx);
      } else if (param !== undefined) {
        try { node[param] = value; } catch(e){}
      }
      break;
      
    case 'sig':
      const sig = signalGens.get(id);
      if(!sig || !param) return;
      if(param in sig.params){
        sig.params[param] = value;
      }
      break;
  }
}

function applyBindString(bindStr, norm, canvas){
  if(!bindStr) return;
  const val = convertPointToParam(norm, bindStr.split(':').pop());
  applyValueToTarget(bindStr, val);
}

function applyPointToBindings(canvas, point){
  if(!canvas || !point) return;
  if(canvas.xBind) applyBindString(canvas.xBind, point.x, canvas);
  if(canvas.yBind) applyBindString(canvas.yBind, point.y, canvas);
}

// ---------------------- Input node playback helpers ----------------------
function startInputPlayback(wrapper) {
  if (!wrapper.buffer) return;
  
  if (wrapper.source) {
    wrapper.source.stop();
  }
  
  wrapper.source = audioCtx.createBufferSource();
  wrapper.source.buffer = wrapper.buffer;
  wrapper.source.connect(wrapper.playbackRate);
  wrapper.playbackRate.connect(wrapper.gainNode);
  wrapper.source.loop = wrapper.isLooping;
  
  wrapper.startTime = audioCtx.currentTime;
  wrapper.source.start(0, wrapper.offset % wrapper.buffer.duration);
  
  wrapper.source.onended = () => {
    if (wrapper.isLooping && wrapper.isPlaying) {
      wrapper.offset = 0;
      wrapper.startTime = audioCtx.currentTime;
      startInputPlayback(wrapper);
    } else {
      wrapper.isPlaying = false;
    }
  };
}

function stopInputPlayback(wrapper) {
  if (wrapper.source) {
    wrapper.source.stop();
    wrapper.source.disconnect();
    wrapper.source = null;
  }
}

// ---------------------- Signal system ----------------------
function evalSignal(sig, t){
  const p = sig.params || {freq:1, amp:1, bias:0};
  const f = p.freq || 1, a = p.amp || 1, b = p.bias || 0;
  switch(sig.type){
    case 'sine': return b + a * Math.sin(2*Math.PI * f * t);
    case 'saw': return b + a * ( ((t*f)%1)*2 - 1 );
    case 'tri': {
      const ph = (t*f)%1;
      return b + a * (ph < 0.5 ? (4*ph -1) : (3 - 4*ph));
    }
    case 'square': return b + ( ((t*f)%1) < 0.5 ? a : -a );
    case 'noise': return b + a * (Math.random()*2 - 1);
  }
  return 0;
}

function evaluateSignals(globalSeconds){
  for(const [id, sig] of signalGens){
    const raw = evalSignal(sig, globalSeconds);
    const norm = (raw + 1) * 0.5; // -1..1 -> 0..1
    
    for(const t of sig.bindings || []){
      if(!t) continue;
      
      const parts = t.split(':');
      if(parts.length < 2) continue;
      
      const type = parts[0];
      const targetId = parts[1];
      const param = parts[2];
      
      let mappedValue;
      
      if(type === 'canvas'){
        if(param === 'speed') mappedValue = 0.1 + norm * 3.9;
        else if(param === 'duration') mappedValue = 100 + Math.round(norm * 60000);
        else mappedValue = norm;
      } else if(type === 'node'){
        mappedValue = convertPointToParam(norm, param);
      } else if(type === 'sig'){
        if(param === 'freq') mappedValue = normToLog(norm, 0.1, 20);
        else if(param === 'amp') mappedValue = norm * 5;
        else if(param === 'bias') mappedValue = -2 + norm * 4;
        else mappedValue = norm;
      }
      
      if(mappedValue !== undefined){
        applyValueToTarget(t, mappedValue);
      }
    }
  }
}

// ---------------------- Canvas model ----------------------
function createCanvasModel(){
  return {
    id: 'C' + (canvasCounter++),
    color: document.getElementById('canvasColor').value,
    frames: new Map(),
    xBind: '',
    yBind: '',
    duration: 10000,
    currentTime: 0,
    isPlaying: false,
    isLooping: true,
    isMuted: false,
    lastUpdate: performance.now(),
    speed: 1,
    lastAppliedFrame: -1
  };
}

function newCanvas(){
  const c = createCanvasModel();
  canvases.push(c);
  activeCanvasId = c.id;
  rebuildCanvasList();
  rebuildAllBindings();
  updateActiveCanvasUI();
  updateTimelineSize();
}

function getCanvas(id){ return canvases.find(c=>c.id===id); }
function deleteCanvas(id){
  canvases = canvases.filter(c=>c.id!==id);
  if(activeCanvasId===id) activeCanvasId = canvases.length?canvases[0].id:null;
  rebuildCanvasList(); rebuildAllBindings(); updateActiveCanvasUI(); updateTimelineSize();
}
function clearCanvas(id){
  const c = getCanvas(id);
  if(c){ c.frames.clear(); c.lastAppliedFrame=-1; renderAll(); renderTimelineVisualization(); logInfo('cleared '+id); }
}
function playCanvas(id){
  const c = getCanvas(id); if(!c || c.isPlaying) return;
  c.isPlaying = true; c.lastUpdate = performance.now(); if(c.currentTime >= c.duration) c.currentTime = 0; c.lastAppliedFrame = -1;
}
function pauseCanvas(id){
  const c = getCanvas(id); if(!c || !c.isPlaying) return;
  c.isPlaying = false; const now = performance.now(); c.currentTime += (now - c.lastUpdate) * c.speed; c.lastUpdate = now;
}
function stopCanvas(id){
  const c = getCanvas(id); if(!c) return;
  c.isPlaying = false; c.currentTime = 0; c.lastUpdate = performance.now(); c.lastAppliedFrame = -1;
}

// ---------------------- Commit stroke into frames ----------------------
function commitStrokeToCanvas(canvas, stroke, offsetMs){
  if(!stroke || stroke.length < 1) return;
  const frames = canvas.frames;
  const startLocal = Math.round(stroke[0].t);
  const endLocal = Math.round(stroke[stroke.length-1].t);
  const startG = offsetMs + startLocal;
  const endG = offsetMs + endLocal;
  const startF = Math.floor(startG / TIMESTEP);
  const endF = Math.floor(endG / TIMESTEP);
  
  // Add interpolation between frames for smoother transitions
  for(let gf = startF; gf <= endF; gf++){
    const gms = gf * TIMESTEP;
    const rel = gms - startG;
    let a = 0;
    while(a + 1 < stroke.length && stroke[a+1].t < rel) a++;
    const A = stroke[a];
    const B = stroke[Math.min(a+1, stroke.length-1)];
    const span = (B.t - A.t) || 1;
    const k = Math.max(0, Math.min(1, (rel - A.t) / span));
    const x = A.x + (B.x - A.x) * k;
    const y = A.y + (B.y - A.y) * k;
    frames.set(gf, {x,y});
  }
  
  logInfo(`committed ${canvas.id} [${startF}..${endF}] frames`);
  updateTimelineSize();
}

// ---------------------- Enhanced rendering with logarithmic grid ----------------------
function renderAll(){
  const ctx = drawCtx;
  if(!ctx) return;
  ctx.save();
  ctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
  ctx.scale(ratio, ratio);
  const w = drawCanvas.width / ratio, h = drawCanvas.height / ratio;
  
  // background
  ctx.fillStyle = '#101010'; ctx.fillRect(0,0,w,h);
  
  // Get active canvas for binding-aware grid
  const activeCanvas = activeCanvasId ? getCanvas(activeCanvasId) : null;
  const xBindParam = activeCanvas?.xBind?.split(':').pop() || '';
  const yBindParam = activeCanvas?.yBind?.split(':').pop() || '';
  
  // Draw grid based on bindings
  const step = 40;
  ctx.strokeStyle = '#111'; ctx.lineWidth = 1;
  
  // X-axis grid (vertical lines)
  if (xBindParam.match(/frequency/)) {
    // Logarithmic grid for frequency
    const minFreq = 20;
    const maxFreq = 20000;
    const gridLines = generateLogGridLines(minFreq, maxFreq, 10);
    
    for (const line of gridLines) {
      const normX = logToNorm(line.value, minFreq, maxFreq);
      const x = normX * w;
      
      ctx.strokeStyle = line.isMajor ? '#222' : '#0f0f0f';
      ctx.lineWidth = line.isMajor ? 1 : 0.5;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, h);
      ctx.stroke();
      
      // Label major grid lines
      if (line.isMajor && line.value <= 2000) {
        ctx.fillStyle = '#444';
        ctx.font = '9px monospace';
        ctx.textAlign = 'center';
        const label = line.value >= 1000 ? (line.value/1000).toFixed(0) + 'k' : line.value.toFixed(0);
        ctx.fillText(label + 'Hz', x, h - 4);
      }
    }
  } else {
    // Linear grid for other parameters
    for(let x=0;x<w;x+=step){ 
      ctx.beginPath(); 
      ctx.moveTo(x,0); 
      ctx.lineTo(x,h); 
      ctx.stroke(); 
    }
  }
  
  // Y-axis grid (horizontal lines)
  if (yBindParam.match(/frequency|gain|volume/)) {
    // Logarithmic grid for frequency/gain on Y-axis
    const minVal = yBindParam.match(/frequency/) ? 20 : 0.001;
    const maxVal = yBindParam.match(/frequency/) ? 20000 : 2;
    const gridLines = generateLogGridLines(minVal, maxVal, 10);
    
    for (const line of gridLines) {
      const normY = 1 - logToNorm(line.value, minVal, maxVal); // Invert for canvas coordinates
      const y = normY * h;
      
      ctx.strokeStyle = line.isMajor ? '#222' : '#0f0f0f';
      ctx.lineWidth = line.isMajor ? 1 : 0.5;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
    }
  } else {
    // Linear grid for other parameters
    for(let y=0;y<h;y+=step){ 
      ctx.beginPath(); 
      ctx.moveTo(0,y); 
      ctx.lineTo(w,y); 
      ctx.stroke(); 
    }
  }
  
  // draw frames for canvases up to their currentTime
  for(const c of canvases){
    const currentFrame = Math.floor(c.currentTime / TIMESTEP);
    for(const [frameIdx, point] of c.frames){
      if(frameIdx <= currentFrame){
        ctx.fillStyle = c.color;
        const px = point.x * w, py = point.y * h;
        const radius = c.id === activeCanvasId ? 3.5 : 2.5;
        ctx.fillRect(px - radius, py - radius, radius*2, radius*2);
      }
    }
  }
  
  // draw active stroke
  if(stroke.length > 0){
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2.5; ctx.beginPath();
    for(let i=0;i<stroke.length;i++){
      const p = stroke[i]; const px = p.x * w, py = p.y * h;
      if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.stroke();
    const last = stroke[stroke.length-1];
    ctx.fillStyle = '#ff6b6b'; ctx.beginPath(); ctx.arc(last.x*w,last.y*h,8,0,Math.PI*2); ctx.fill();
  }
  
  // playhead markers
  for(const c of canvases){
    const curFrame = Math.floor(c.currentTime / TIMESTEP);
    const point = c.frames.get(curFrame);
    if(point){
      ctx.fillStyle = c.color;
      const px = point.x * w, py = point.y * h;
      ctx.beginPath(); ctx.arc(px,py,6,0,Math.PI*2); ctx.fill();
    }
  }
  
  // text info
  ctx.fillStyle = '#ddd'; ctx.font = isMobile ? '10px monospace' : '12px monospace';
  ctx.fillText(`Active: ${activeCanvasId || '‚Äî'}`, 8, 14);
  if(activeCanvasId){
    const c = getCanvas(activeCanvasId);
    if(c) ctx.fillText(`Time: ${(c.currentTime/1000).toFixed(3)}s`, 8, 28);
  }
  
  // Show scaling info
  if (activeCanvas) {
    if (xBindParam.match(/frequency/)) {
      ctx.fillStyle = '#666';
      ctx.fillText('X: Log', w - 50, 14);
    }
    if (yBindParam.match(/frequency|gain|volume/)) {
      ctx.fillStyle = '#666';
      ctx.fillText('Y: Log', w - 50, 28);
    }
  }
  
  ctx.restore();
}

// ---------------------- Timeline visualization ----------------------
let timelinePixelsPerMs = Number(document.getElementById('zoomRange').value);
let timelineCssWidth = 800;

function updateTimelineSize(){
  const maxDur = canvases.reduce((m,c)=>Math.max(m, c.duration), 1000);
  timelinePixelsPerMs = Number(document.getElementById('zoomRange').value);
  const desiredWidth = Math.max(timelineContainer.clientWidth, Math.ceil(80 + maxDur * timelinePixelsPerMs));
  timelineCssWidth = desiredWidth;
  timelineCanvas.style.width = desiredWidth + 'px';
  timelineCanvas.width = Math.floor(desiredWidth * ratio);
  timelineCanvas.height = Math.floor(160 * ratio);
  renderTimelineVisualization();
}

function renderTimelineVisualization(){
  const cvs = timelineCanvas;
  const ctx = cvs.getContext('2d');
  const w = cvs.width / ratio;
  const h = cvs.height / ratio;
  ctx.save();
  ctx.scale(ratio, ratio);
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = '#050505'; ctx.fillRect(0,0,w,h);
  if(canvases.length===0){
    ctx.fillStyle = '#999'; ctx.fillText('No canvases', 10, 20); ctx.restore(); return;
  }
  const laneH = h / canvases.length;
  for(let i=0;i<canvases.length;i++){
    const c = canvases[i];
    const y0 = Math.round(i * laneH);
    // lane background
    ctx.fillStyle = '#080808'; ctx.fillRect(0, y0, w, laneH);
    // left header
    ctx.fillStyle = '#0b0b0b'; ctx.fillRect(0, y0, 80, laneH);
    ctx.fillStyle = c.color; ctx.font = '11px monospace'; ctx.fillText(`${c.id} ${c.isMuted?'üîá':''}`, 6, y0 + 14);
    // grid seconds
    ctx.strokeStyle = '#121212'; ctx.lineWidth = 1;
    const seconds = Math.ceil(c.duration / 1000);
    for(let s=0;s<=seconds;s++){
      const x = 80 + s * 1000 * timelinePixelsPerMs;
      ctx.beginPath(); ctx.moveTo(x, y0); ctx.lineTo(x, y0 + laneH); ctx.stroke();
    }
    // frames
    ctx.fillStyle = c.color;
    for(const [frameIdx, p] of c.frames){
      const tms = frameIdx * TIMESTEP;
      if(tms > c.duration) continue;
      const x = 80 + tms * timelinePixelsPerMs;
      const y = y0 + (1 - p.y) * (laneH - 6) + 3;
      ctx.fillRect(x-1, Math.round(y)-1, 2, 2);
    }
    // playhead
    const playX = 80 + c.currentTime * timelinePixelsPerMs;
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(playX, y0); ctx.lineTo(playX, y0 + laneH); ctx.stroke();
    // loop indicator
    if(c.isLooping){
      ctx.fillStyle = 'rgba(255,107,107,0.08)'; ctx.fillRect(80, y0 + laneH - 6, Math.max(0.1, c.duration * timelinePixelsPerMs), 6);
    }
  }
  ctx.restore();
}

// ---------------------- Resize handling ----------------------
function resizeAll(){
  isMobile = window.innerWidth <= 768;
  ratio = window.devicePixelRatio || 1;
  const rect = drawCanvas.getBoundingClientRect();
  drawCanvas.width = Math.floor(rect.width * ratio);
  drawCanvas.height = Math.floor(rect.height * ratio);
  updateTimelineSize();
  renderAll();
  renderTimelineVisualization();
}

window.addEventListener('resize', resizeAll);
document.getElementById('zoomRange').addEventListener('input', ()=>{ updateTimelineSize(); renderTimelineVisualization(); });

// ---------------------- Tick loop ----------------------
let lastRAF = 0;
function tick(ts){
  if(!lastRAF) lastRAF = ts;
  const now = performance.now();
  const globalSeconds = now / 1000;
  
  // update canvases
  for(const c of canvases){
    if(c.isPlaying){
      const dt = now - c.lastUpdate;
      c.lastUpdate = now;
      c.currentTime += dt * c.speed;
      if(c.isLooping) c.currentTime = c.currentTime % c.duration;
      else if(c.currentTime > c.duration){ c.currentTime = c.duration; c.isPlaying = false; }
      const frameIdx = Math.floor(c.currentTime / TIMESTEP);
      if(frameIdx !== c.lastAppliedFrame){
        c.lastAppliedFrame = frameIdx;
        const p = c.frames.get(frameIdx);
        if(p && !c.isMuted) applyPointToBindings(c, p);
      }
    }
  }

  evaluateSignals(globalSeconds);

  // update active canvas UI
  if(activeCanvasId){
    const a = getCanvas(activeCanvasId);
    if(a){
      document.getElementById('canvasTime').textContent = (a.currentTime/1000).toFixed(3)+'s';
      const slider = document.getElementById('canvasTimeSlider');
      slider.max = a.duration; slider.value = a.currentTime;
    }
  }

  renderAll();
  renderTimelineVisualization();

  lastRAF = ts;
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

// ---------------------- Pointer drawing ----------------------
function toLocalPoint(ev){
  const r = drawCanvas.getBoundingClientRect();
  // Handle touch events
  let clientX, clientY;
  if (ev.touches && ev.touches[0]) {
    clientX = ev.touches[0].clientX;
    clientY = ev.touches[0].clientY;
  } else if (ev.clientX !== undefined) {
    clientX = ev.clientX;
    clientY = ev.clientY;
  } else if (ev.changedTouches && ev.changedTouches[0]) {
    clientX = ev.changedTouches[0].clientX;
    clientY = ev.changedTouches[0].clientY;
  } else {
    return { x: 0, y: 0 };
  }
  
  return { 
    x: Math.max(0, Math.min(1, (clientX - r.left) / r.width)), 
    y: Math.max(0, Math.min(1, (clientY - r.top) / r.height)) 
  };
}

// Enhanced pointer handling for mobile
function handlePointerDown(e) {
  e.preventDefault();
  if(!activeCanvasId) return;
  try{ 
    if (e.pointerId) drawCanvas.setPointerCapture(e.pointerId); 
  } catch(e){}
  drawing = true;
  stroke = [];
  gestureOffsetMs = getCanvasById(activeCanvasId).currentTime;
  strokeStartTime = performance.now();
  const p = toLocalPoint(e);
  const pt = {t:0, x:p.x, y:p.y};
  stroke.push(pt);
  applyPointToBindings(getCanvasById(activeCanvasId), pt);
  liveIndicator.style.display = 'inline';
  renderAll();
}

function handlePointerMove(e) {
  if(!drawing) return;
  e.preventDefault();
  const p = toLocalPoint(e);
  const pt = { t: performance.now() - strokeStartTime, x: p.x, y: p.y };
  stroke.push(pt);
  applyPointToBindings(getCanvasById(activeCanvasId), pt);
  renderAll();
}

function handlePointerUp(e) {
  if(!drawing) return;
  e.preventDefault();
  try{ 
    if (e.pointerId) drawCanvas.releasePointerCapture(e.pointerId); 
  }catch(e){}
  drawing = false;
  const c = getCanvasById(activeCanvasId);
  if(c && stroke.length > 0) commitStrokeToCanvas(c, stroke, gestureOffsetMs);
  stroke = [];
  liveIndicator.style.display = 'none';
  renderAll();
  renderTimelineVisualization();
}

// Add event listeners for both pointer and touch
drawCanvas.addEventListener('pointerdown', handlePointerDown);
drawCanvas.addEventListener('pointermove', handlePointerMove);
drawCanvas.addEventListener('pointerup', handlePointerUp);
drawCanvas.addEventListener('pointercancel', handlePointerUp);

// Additional touch event listeners for better mobile support
drawCanvas.addEventListener('touchstart', handlePointerDown, { passive: false });
drawCanvas.addEventListener('touchmove', handlePointerMove, { passive: false });
drawCanvas.addEventListener('touchend', handlePointerUp, { passive: false });
drawCanvas.addEventListener('touchcancel', handlePointerUp, { passive: false });

// Prevent context menu on long press (mobile)
drawCanvas.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  return false;
});

// ---------------------- Connection List ----------------------
function rebuildConnectionList(){
  const el = document.getElementById('connectionList'); 
  el.innerHTML = '';
  
  if(connections.length === 0){
    el.innerHTML = '<div class="mono small" style="padding:8px">No connections</div>';
    return;
  }
  
  connections.forEach((conn, index) => {
    const div = document.createElement('div');
    div.className = 'connection-item';
    
    const label = document.createElement('div');
    label.className = 'connection-label mono small';
    label.textContent = `${conn.source} ‚Üí ${conn.target}`;
    
    const controls = document.createElement('div');
    controls.className = 'connection-controls';
    
    const disconnectBtn = document.createElement('button');
    disconnectBtn.textContent = '‚úï';
    disconnectBtn.title = 'Disconnect';
    disconnectBtn.style.padding = '2px 6px';
    disconnectBtn.style.fontSize = '10px';
    disconnectBtn.addEventListener('click', () => {
      disconnectConnection(conn);
    });
    
    controls.appendChild(disconnectBtn);
    div.appendChild(label);
    div.appendChild(controls);
    el.appendChild(div);
  });
}

// ---------------------- Enhanced UI rebuilders ----------------------
function rebuildNodeList(){
  const el = document.getElementById('nodeList'); el.innerHTML = '';
  if(audioNodes.size===0){ el.innerHTML = '<div class="mono small" style="padding:8px">No nodes</div>'; return; }
  
  for(const [id,info] of audioNodes){
    const div = document.createElement('div'); div.className='item'; div.style.display='flex'; div.style.flexDirection='column'; div.style.padding='6px';
    
    const row = document.createElement('div'); row.style.display='flex'; row.style.justifyContent='space-between'; row.style.marginBottom='6px';
    const left = document.createElement('div'); left.textContent = id+' ('+info.type+')'; left.style.flex='1';
    
    // Show outgoing connections
    const outgoing = connections.filter(c => c.source === id);
    if (outgoing.length > 0) {
      const connText = document.createElement('div');
      connText.className = 'mono small';
      connText.style.color = '#888';
      connText.textContent = `‚Üí ${outgoing.map(c => c.target).join(', ')}`;
      left.appendChild(connText);
    }
    
    // Special UI for input nodes
    if (info.type === 'input' && info.wrapper) {
      const wrapper = info.wrapper;
      const fileUI = document.createElement('div'); fileUI.className='file-input-ui';
      
      // File input button
      const fileBtn = document.createElement('button'); 
      fileBtn.textContent = wrapper.buffer ? (wrapper.isMicrophone ? 'Recorded' : 'Change File') : 'Load File';
      fileBtn.addEventListener('click', () => {
        const input = document.createElement('input'); input.type='file'; input.accept='audio/*';
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          
          const reader = new FileReader();
          reader.onload = (ev) => {
            audioCtx.decodeAudioData(ev.target.result, (buffer) => {
              wrapper.buffer = buffer;
              wrapper.duration = buffer.duration;
              wrapper.offset = 0;
              wrapper.isMicrophone = false;
              
              // Stop current playback if playing
              stopInputPlayback(wrapper);
              wrapper.isPlaying = false;
              
              rebuildNodeList();
              logInfo(`Loaded: ${file.name} (${buffer.duration.toFixed(2)}s)`);
            }, (err) => {
              logInfo('Failed to decode audio: ' + err.message);
            });
          };
          reader.readAsArrayBuffer(file);
        };
        input.click();
      });
      
      // Mic recording button
      const micBtn = document.createElement('button'); 
      if (wrapper.isRecording) {
        micBtn.textContent = '‚óè Stop Recording';
        micBtn.style.color = '#ff6b6b';
      } else {
        micBtn.textContent = wrapper.isMicrophone ? 'Re-record' : 'Record Mic';
      }
      
      micBtn.addEventListener('click', () => {
        if (wrapper.isRecording) {
          // Stop recording
          if (wrapper.mediaRecorder && wrapper.mediaRecorder.state !== 'inactive') {
            wrapper.mediaRecorder.stop();
          }
          if (wrapper.stream) {
            wrapper.stream.getTracks().forEach(track => track.stop());
          }
          wrapper.isRecording = false;
          rebuildNodeList();
          logInfo('Recording stopped');
        } else {
          // Start recording
          navigator.mediaDevices.getUserMedia({ audio: true })
            .then((stream) => {
              wrapper.stream = stream;
              wrapper.isRecording = true;
              wrapper.recordedChunks = [];
              
              wrapper.mediaRecorder = new MediaRecorder(stream);
              
              wrapper.mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) {
                  wrapper.recordedChunks.push(e.data);
                }
              };
              
              wrapper.mediaRecorder.onstop = () => {
                const audioBlob = new Blob(wrapper.recordedChunks, { type: 'audio/webm' });
                const reader = new FileReader();
                reader.onload = () => {
                  audioCtx.decodeAudioData(reader.result, (buffer) => {
                    wrapper.buffer = buffer;
                    wrapper.duration = buffer.duration;
                    wrapper.offset = 0;
                    wrapper.isMicrophone = true;
                    wrapper.isPlaying = false;
                    
                    rebuildNodeList();
                    logInfo(`Recorded ${buffer.duration.toFixed(2)}s from mic`);
                  });
                };
                reader.readAsArrayBuffer(audioBlob);
              };
              
              wrapper.mediaRecorder.start();
              rebuildNodeList();
              logInfo('Recording... Click again to stop');
            })
            .catch((err) => {
              logInfo('Microphone access denied: ' + err.message);
            });
        }
      });
      
      // Play/Pause button (only if buffer exists)
      const playBtn = document.createElement('button');
      if (wrapper.buffer) {
        playBtn.textContent = wrapper.isPlaying ? 'Pause' : 'Play';
        playBtn.addEventListener('click', () => {
          if (wrapper.isPlaying) {
            // Pause
            stopInputPlayback(wrapper);
            wrapper.isPlaying = false;
            wrapper.offset += audioCtx.currentTime - wrapper.startTime;
          } else {
            // Play
            wrapper.isPlaying = true;
            startInputPlayback(wrapper);
          }
          rebuildNodeList();
        });
      } else {
        playBtn.textContent = 'Play';
        playBtn.disabled = true;
      }
      
      // Loop toggle button
      const loopBtn = document.createElement('button');
      loopBtn.textContent = wrapper.isLooping ? 'üîÅ' : '‚Üª';
      loopBtn.title = wrapper.isLooping ? 'Looping on' : 'Looping off';
      loopBtn.addEventListener('click', () => {
        wrapper.isLooping = !wrapper.isLooping;
        if (wrapper.source) {
          wrapper.source.loop = wrapper.isLooping;
        }
        rebuildNodeList();
      });
      
      // Reset button
      const resetBtn = document.createElement('button');
      resetBtn.textContent = 'Reset';
      resetBtn.addEventListener('click', () => {
        wrapper.offset = 0;
        if (wrapper.isPlaying && wrapper.buffer) {
          stopInputPlayback(wrapper);
          startInputPlayback(wrapper);
        }
        rebuildNodeList();
      });
      
      fileUI.appendChild(fileBtn);
      fileUI.appendChild(micBtn);
      
      const controlRow = document.createElement('div');
      controlRow.style.display = 'flex';
      controlRow.style.gap = '4px';
      controlRow.appendChild(playBtn);
      controlRow.appendChild(loopBtn);
      controlRow.appendChild(resetBtn);
      fileUI.appendChild(controlRow);
      
      // Progress bar for audio file
      if (wrapper.buffer) {
        const progressDiv = document.createElement('div'); progressDiv.className='progress-bar';
        const progressInner = document.createElement('div'); progressInner.className='progress-bar-inner';
        const progress = Math.min(1, wrapper.offset / wrapper.duration);
        progressInner.style.width = `${progress * 100}%`;
        progressDiv.appendChild(progressInner);
        fileUI.appendChild(progressDiv);
        
        // Recording indicator
        if (wrapper.isRecording) {
          const recordingIndicator = document.createElement('div');
          recordingIndicator.className = 'recording-indicator';
          recordingIndicator.textContent = '‚óè RECORDING';
          fileUI.appendChild(recordingIndicator);
        }
      }
      
      div.appendChild(fileUI);
    }
    
    // Connection dropdown (only show if not an input node or if we want to connect from input)
    const conn = document.createElement('select'); 
    conn.innerHTML = '<option value="">(connect)</option><option value="dest">‚Üí dest</option>';
    for(const [id2, info2] of audioNodes){ 
      if(id2===id) continue; 
      const opt=document.createElement('option'); 
      opt.value=id2; 
      opt.textContent='‚Üí '+id2; 
      conn.appendChild(opt); 
    }
    conn.addEventListener('change', ()=>{ 
      if(conn.value) {
        connectNode(id, conn.value);
      }
      conn.value=''; 
    });
    
    const del = document.createElement('button'); 
    del.textContent='del'; 
    del.addEventListener('click', ()=>{
      // Clean up input node resources
      if (info.type === 'input' && info.wrapper) {
        if (info.wrapper.source) {
          info.wrapper.source.stop();
          info.wrapper.source.disconnect();
        }
        if (info.wrapper.stream) {
          info.wrapper.stream.getTracks().forEach(track => track.stop());
        }
        if (info.wrapper.mediaRecorder && info.wrapper.mediaRecorder.state !== 'inactive') {
          info.wrapper.mediaRecorder.stop();
        }
      }
      
      // Remove all connections involving this node
      const connectionsToRemove = connections.filter(c => c.source === id || c.target === id);
      connectionsToRemove.forEach(c => disconnectConnection(c));
      
      audioNodes.delete(id); 
      rebuildNodeList(); 
      rebuildAllBindings();
      rebuildConnectionList();
    });
    
    row.appendChild(left); 
    if (info.type !== 'input' || (info.wrapper && info.wrapper.buffer)) {
      row.appendChild(conn); 
    }
    row.appendChild(del); 
    div.appendChild(row);
    el.appendChild(div);
  }
}

function rebuildSigList(){
  const el = document.getElementById('sigList'); el.innerHTML = '';
  if(signalGens.size===0){ el.innerHTML = '<div class="mono small" style="padding:8px">No signals</div>'; return; }
  for(const [id,sig] of signalGens){
    const box = document.createElement('div'); box.className='item'; box.style.flexDirection='column'; box.style.alignItems='stretch'; box.style.padding='6px';
    const row = document.createElement('div'); row.style.display='flex'; row.style.justifyContent='space-between';
    const label = document.createElement('div'); label.textContent=id+' ('+sig.type+')'; const del = document.createElement('button'); del.textContent='del';
    del.addEventListener('click', ()=>{ signalGens.delete(id); rebuildSigList(); rebuildAllBindings(); });
    row.appendChild(label); row.appendChild(del); box.appendChild(row);
    
    const params = document.createElement('div'); params.style.display='flex'; params.style.gap='6px'; params.style.marginTop='6px';
    const freq = document.createElement('input'); freq.type='number'; freq.step='0.01'; freq.value = sig.params.freq; freq.style.width='64px'; freq.addEventListener('change',(e)=>sig.params.freq=Number(e.target.value));
    const amp = document.createElement('input'); amp.type='number'; amp.step='0.01'; amp.value = sig.params.amp; amp.style.width='64px'; amp.addEventListener('change',(e)=>sig.params.amp=Number(e.target.value));
    const bias = document.createElement('input'); bias.type='number'; bias.step='0.01'; bias.value = sig.params.bias; bias.style.width='64px'; bias.addEventListener('change',(e)=>sig.params.bias=Number(e.target.value));
    params.appendChild(document.createTextNode('f')); params.appendChild(freq); params.appendChild(document.createTextNode('A')); params.appendChild(amp); params.appendChild(document.createTextNode('b')); params.appendChild(bias);
    box.appendChild(params);
    
    // bindings UI
    const bindings = document.createElement('div'); bindings.style.marginTop='6px';
    (sig.bindings||[]).forEach((tgt,i)=>{
      const r = document.createElement('div'); r.style.display='flex'; r.style.justifyContent='space-between';
      const tdiv = document.createElement('div'); tdiv.textContent = tgt; const rem = document.createElement('button'); rem.textContent='‚úï'; rem.addEventListener('click',()=>{ sig.bindings.splice(i,1); rebuildSigList(); });
      r.appendChild(tdiv); r.appendChild(rem); bindings.appendChild(r);
    });
    
    // add-binding row
    const addRow = document.createElement('div'); addRow.style.display='flex'; addRow.style.gap='6px'; addRow.style.marginTop='6px';
    const sel = document.createElement('select'); sel.style.flex='1'; sel.innerHTML = '<option value="">(bind target)</option>';
    
    // Audio node parameters
    for(const [nid,info] of audioNodes){ 
      const params = getNumericParams(info.node, info.wrapper); 
      for(const p of params){ 
        const opt=document.createElement('option'); 
        opt.value = `node:${nid}:${p.key}`; 
        opt.textContent = `node:${nid}:${p.key}`; 
        sel.appendChild(opt); 
      } 
    }
    
    // Canvas parameters
    for(const c of canvases){ 
      const o1=document.createElement('option'); o1.value=`canvas:${c.id}:speed`; o1.textContent=`canvas:${c.id}:speed`; sel.appendChild(o1); 
      const o2=document.createElement('option'); o2.value=`canvas:${c.id}:duration`; o2.textContent=`canvas:${c.id}:duration`; sel.appendChild(o2);
    }
    
    // Other signal generator parameters (exclude self)
    for(const [oid, osig] of signalGens){
      if(oid === id) continue;
      const params = getSignalGenParams(osig);
      for(const p of params){
        const opt = document.createElement('option');
        opt.value = `sig:${oid}:${p.key}`;
        opt.textContent = `sig:${oid}:${p.key}`;
        sel.appendChild(opt);
      }
    }
    
    const addBtn = document.createElement('button'); addBtn.textContent='add'; addBtn.addEventListener('click', ()=>{ if(!sel.value) return; sig.bindings = sig.bindings||[]; sig.bindings.push(sel.value); rebuildSigList(); });
    addRow.appendChild(sel); addRow.appendChild(addBtn);
    box.appendChild(bindings); box.appendChild(addRow);
    el.appendChild(box);
  }
}

function rebuildCanvasList(){
  const el = document.getElementById('canvasList'); el.innerHTML = '';
  if(canvases.length===0){ el.innerHTML = '<div class="mono small" style="padding:8px">No canvases</div>'; return; }
  canvases.forEach((c)=>{
    const out = document.createElement('div'); out.style.padding='6px'; out.style.borderBottom='1px solid #141414';
    const row = document.createElement('div'); row.style.display='flex'; row.style.gap='6px';
    const b = document.createElement('button'); b.textContent = c.id; b.style.flex='1'; b.style.background = (c.id===activeCanvasId)?'#333':'#1a1a1a';
    b.addEventListener('click', ()=>{ activeCanvasId = c.id; rebuildCanvasList(); rebuildAllBindings(); updateActiveCanvasUI(); });
    const col = document.createElement('input'); col.type='color'; col.value = c.color; col.addEventListener('input',(e)=>{ c.color = e.target.value; renderAll(); renderTimelineVisualization(); });
    row.appendChild(b); row.appendChild(col); out.appendChild(row);
    
    const ctrl = document.createElement('div'); ctrl.style.display='flex'; ctrl.style.gap='6px'; ctrl.style.marginTop='6px';
    const play = document.createElement('button'); play.textContent = c.isPlaying ? '‚ñê‚ñê':'‚ñ∂'; play.addEventListener('click',(e)=>{ e.stopPropagation(); if(c.isPlaying) pauseCanvas(c.id); else { playCanvas(c.id); } rebuildCanvasList(); });
    const stop = document.createElement('button'); stop.textContent='‚ñ†'; stop.addEventListener('click',(e)=>{ e.stopPropagation(); stopCanvas(c.id); rebuildCanvasList(); });
    const loop = document.createElement('button'); loop.textContent = c.isLooping ? '‚Üª':'‚Ü∫'; loop.addEventListener('click',(e)=>{ e.stopPropagation(); c.isLooping=!c.isLooping; rebuildCanvasList(); });
    const mute = document.createElement('button'); mute.textContent = c.isMuted ? 'üîá':'üîä'; mute.addEventListener('click',(e)=>{ e.stopPropagation(); c.isMuted=!c.isMuted; rebuildCanvasList(); });
    ctrl.appendChild(play); ctrl.appendChild(stop); ctrl.appendChild(loop); ctrl.appendChild(mute);
    out.appendChild(ctrl);
    el.appendChild(out);
  });
}

function rebuildAllBindings(){
  const xSel = document.getElementById('xBind'), ySel = document.getElementById('yBind');
  xSel.innerHTML = ''; ySel.innerHTML = '';
  const none = document.createElement('option'); none.value=''; none.textContent='(none)';
  xSel.appendChild(none.cloneNode(true)); ySel.appendChild(none.cloneNode(true));
  
  // Audio node parameters
  for(const [id, info] of audioNodes){
    const params = getNumericParams(info.node, info.wrapper);
    for(const p of params){
      const opt = document.createElement('option'); opt.value = `node:${id}:${p.key}`; opt.textContent = `node:${id}:${p.key}`;
      xSel.appendChild(opt); ySel.appendChild(opt.cloneNode(true));
    }
  }
  
  // Canvas parameters
  for(const c of canvases){
    const o1 = document.createElement('option'); o1.value=`canvas:${c.id}:speed`; o1.textContent=`canvas:${c.id}:speed`;
    const o2 = document.createElement('option'); o2.value=`canvas:${c.id}:duration`; o2.textContent=`canvas:${c.id}:duration`;
    xSel.appendChild(o1); xSel.appendChild(o2); ySel.appendChild(o1.cloneNode(true)); ySel.appendChild(o2.cloneNode(true));
  }
  
  // Signal generator parameters
  for(const [id, sig] of signalGens){
    const params = getSignalGenParams(sig);
    for(const p of params){
      const opt = document.createElement('option'); opt.value = `sig:${id}:${p.key}`; opt.textContent = `sig:${id}:${p.key}`;
      xSel.appendChild(opt); ySel.appendChild(opt.cloneNode(true));
    }
  }
  
  if(activeCanvasId){
    const c = getCanvas(activeCanvasId);
    if(c){ xSel.value = c.xBind || ''; ySel.value = c.yBind || ''; }
  }
}

// ---------------------- UI wiring ----------------------
document.querySelectorAll('[data-mk]').forEach(btn=>btn.addEventListener('click', ()=>makeAudioNode(btn.getAttribute('data-mk'))));

document.querySelectorAll('[data-sig]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const type = btn.getAttribute('data-sig');
    const id = uid('S');
    signalGens.set(id, { id, type, params:{freq:1,amp:1,bias:0}, bindings:[]});
    rebuildSigList(); rebuildAllBindings();
  });
});

document.getElementById('newCanvas').addEventListener('click', ()=>{ newCanvas(); rebuildCanvasList(); updateActiveCanvasUI(); });
document.getElementById('delCanvas').addEventListener('click', ()=>{ if(activeCanvasId) deleteCanvas(activeCanvasId); rebuildCanvasList(); updateActiveCanvasUI(); });
document.getElementById('clearCanvas').addEventListener('click', ()=>{ if(activeCanvasId) clearCanvas(activeCanvasId); });

document.getElementById('playAll').addEventListener('click', ()=>{ canvases.forEach(c=>{ if(!c.isMuted) playCanvas(c.id); }); });
document.getElementById('pauseAll').addEventListener('click', ()=>{ canvases.forEach(c=>pauseCanvas(c.id)); });
document.getElementById('stopAll').addEventListener('click', ()=>{ canvases.forEach(c=>stopCanvas(c.id)); renderAll(); renderTimelineVisualization(); });

document.getElementById('canvasDuration').addEventListener('change',(e)=>{ if(activeCanvasId){ const c=getCanvas(activeCanvasId); c.duration=Math.max(100,Number(e.target.value)); if(c.currentTime>c.duration) c.currentTime=c.duration; updateTimelineSize(); renderTimelineVisualization(); }});
document.getElementById('canvasLoop').addEventListener('change',(e)=>{ if(activeCanvasId) getCanvas(activeCanvasId).isLooping = e.target.checked; });
document.getElementById('canvasMute').addEventListener('change',(e)=>{ if(activeCanvasId) getCanvas(activeCanvasId).isMuted = e.target.checked; rebuildCanvasList(); });
document.getElementById('canvasSpeed').addEventListener('change',(e)=>{ if(activeCanvasId) getCanvas(activeCanvasId).speed = Number(e.target.value) || 1; });
document.getElementById('canvasTimeSlider').addEventListener('input',(e)=>{ if(activeCanvasId){ const c = getCanvas(activeCanvasId); c.currentTime = Number(e.target.value); c.lastAppliedFrame = Math.floor(c.currentTime / TIMESTEP); renderAll(); renderTimelineVisualization(); }});
document.getElementById('xBind').addEventListener('change',(e)=>{ if(activeCanvasId) getCanvas(activeCanvasId).xBind = e.target.value; });
document.getElementById('yBind').addEventListener('change',(e)=>{ if(activeCanvasId) getCanvas(activeCanvasId).yBind = e.target.value; });
document.getElementById('zoomRange').addEventListener('input', ()=>{ updateTimelineSize(); });

document.querySelectorAll('[data-mk]').forEach(el=>el.addEventListener('click', ()=>{ rebuildNodeList(); rebuildAllBindings(); }));
document.getElementById('canvasColor').addEventListener('change', ()=>{ if(activeCanvasId){ const c=getCanvas(activeCanvasId); c.color=document.getElementById('canvasColor').value; renderAll(); renderTimelineVisualization(); }});

// resume audio on pointerdown
window.addEventListener('pointerdown', ()=>{ if(audioCtx.state==='suspended') audioCtx.resume(); });

// ---------------------- Enhanced Export/Import ----------------------
document.getElementById('exportBtn').addEventListener('click', ()=>{
  const data = {
    version: 5, // bumped version for new features
    canvases: canvases.map(c=>({id:c.id,color:c.color,duration:c.duration,frames:Array.from(c.frames.entries()),xBind:c.xBind,yBind:c.yBind,speed:c.speed,isLooping:c.isLooping,isMuted:c.isMuted,currentTime:c.currentTime})),
    signals: Array.from(signalGens.values()).map(s=>({id:s.id,type:s.type,params:s.params,bindings:s.bindings})),
    nodes: Array.from(audioNodes.entries()).map(([id,info])=>({id,type:info.type})),
    connections
  };
  const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = `project-${Date.now()}.json`; document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
  logInfo('Exported project');
});

const importFile = document.getElementById('importFile');
document.getElementById('importBtn').addEventListener('click', ()=>importFile.click());
importFile.addEventListener('change', (e)=>{
  const file = e.target.files[0]; if(!file) return;
  const reader = new FileReader();
  reader.onload = (ev)=>{
    try{
      const data = JSON.parse(ev.target.result);
      audioNodes.clear(); connections.length=0; canvases.length=0; signalGens.clear(); canvasCounter=0;
      
      if(data.canvases){
        data.canvases.forEach(cd=>{
          const c = createCanvasModel();
          c.id = cd.id; c.color = cd.color; c.duration = cd.duration || 10000;
          c.xBind = cd.xBind || ''; c.yBind = cd.yBind || ''; c.speed = cd.speed || 1; c.isLooping = cd.isLooping !== undefined ? cd.isLooping : true; c.isMuted = cd.isMuted || false;
          c.currentTime = cd.currentTime || 0; if(cd.frames) c.frames = new Map(cd.frames);
          canvases.push(c); canvasCounter = Math.max(canvasCounter, parseInt(c.id.slice(1)) + 1 || canvasCounter);
        });
      }
      
      if(data.signals){
        data.signals.forEach(s=> signalGens.set(s.id, {id:s.id,type:s.type,params:s.params || {freq:1,amp:1,bias:0},bindings:s.bindings || []}));
      }
      
      if(data.nodes){
        data.nodes.forEach(n=>{ try{ makeAudioNode(n.type); }catch(e){} });
      }
      
      if(data.connections){
        data.connections.forEach(conn=>{
          connections.push(conn);
        });
      }
      
      rebuildNodeList(); rebuildSigList(); rebuildCanvasList(); rebuildConnectionList(); rebuildAllBindings(); updateActiveCanvasUI(); updateTimelineSize(); renderAll(); renderTimelineVisualization(); logInfo('Imported project');
    }catch(err){
      logInfo('Import failed: '+err.message);
    }
  };
  reader.readAsText(file); e.target.value = '';
});

// ---------------------- Initialization ----------------------
function updateActiveCanvasUI(){
  const name = document.getElementById('activeCanvasName');
  if(!activeCanvasId){ name.textContent='‚Äî'; document.getElementById('canvasDuration').disabled=true; document.getElementById('canvasLoop').disabled=true; document.getElementById('canvasMute').disabled=true; document.getElementById('canvasSpeed').disabled=true; document.getElementById('canvasTimeSlider').disabled=true; return; }
  const c = getCanvas(activeCanvasId); if(!c) return;
  name.textContent = c.id; name.style.color = c.color;
  document.getElementById('canvasDuration').disabled=false; document.getElementById('canvasDuration').value = c.duration;
  document.getElementById('canvasLoop').disabled=false; document.getElementById('canvasLoop').checked = c.isLooping;
  document.getElementById('canvasMute').disabled=false; document.getElementById('canvasMute').checked = c.isMuted;
  document.getElementById('canvasSpeed').disabled=false; document.getElementById('canvasSpeed').value = c.speed;
  document.getElementById('canvasTimeSlider').disabled=false; document.getElementById('canvasTimeSlider').max = c.duration; document.getElementById('canvasTimeSlider').value = c.currentTime;
}

// minimal initial state
newCanvas();
rebuildCanvasList();
rebuildAllBindings();
rebuildNodeList();
rebuildSigList();
rebuildConnectionList();
updateActiveCanvasUI();

// set a couple nodes for convenience
setTimeout(()=>{
  const o = makeAudioNode('osc');
  const g = makeAudioNode('gain');
  if(o && g){ 
    setTimeout(()=>{ 
      try{ connectNode(o,g); connectNode(g,'dest'); }catch(e){} 
    }, 80); 
    if(activeCanvasId){ 
      const c = getCanvas(activeCanvasId); 
      c.xBind = `node:${o}:frequency`; 
      c.yBind = `node:${g}:gain`; 
      rebuildAllBindings(); 
    } 
  }
}, 200);

// final initial sizing
setTimeout(()=>{ resizeAll(); }, 150);
</script>
</body>
</html>
